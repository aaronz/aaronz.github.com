<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>High Performance JavaScript</title>

    <meta name="description" content="JavaScript Performance Best Practices">
    <meta name="author" content="Aaron Zhang">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/serif.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
    if (window.location.search.match(/print-pdf/gi)) {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    }
    </script>

    <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
</head>

<body>

    <div class="reveal">

        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <h1>High Performance JavaScript</h1>
                <h3>JavaScript Performance Best Practices</h3>
                <p>
                    <small><a href="http://browserwork.com/contact.html" target="_blank">Aaron Zhang</a> - <a href="http://www.browserwork.com" target="_blank">Browserwork.com</a>
                    </small>
                </p>
            </section>
            <section>
                <section>
                    <h2>JavaScript Overview</h2>
                </section>
                <section>
                    <h3>JavaScript History</h3>
                    <ul>
                        <li>Beginnings at Netscape</li>
                        <li>Server-side JavaScript</li>
                        <li>Adoption by Microsoft - IE3.0 - 1996</li>
                        <li>Standardization - Ecma - 1997</li>
                        <li>Later developments</li>
                    </ul>
                </section>
                <section>
                    <h3>Features</h3>
                    <ul>
                        <li>Imperative and structured</li>
                        <li>Dynamic</li>
                        <li>Functional</li>
                        <li>Prototype-based</li>
                        <li>Implicit and explicit delegation</li>
                        <li>Miscellaneous</li>
                        <li>Vendor-specific extensions</li>
                    </ul>
                </section>
                <section>
                    <h3>Major Components</h3>
                    <ul>
                        <li>ECMAScript - which is defined in ECMA - 262 and provides the core functionality</li>
                        <li>DOM (Document Object Model) - which provides methods and interfaces for working with the content of a web page</li>
                        <li>BOM (Browser Object Model) - which provides methods and interfaces for interacting with the browser</li>
                    </ul>
                </section>
                <section>
                    <h3>ECMAScript</h3>
                    <p>ECMAScript is the scripting language standardized by Ecma International in the ECMA-262 specification and ISO/IEC 16262. The language is widely used for client-side scripting on the web, in the form of several well-known implementations such as JavaScript, JScript and ActionScript.</p>
                    <ul>
                        <li>Syntax</li>
                        <li>Types</li>
                        <li>Statements</li>
                        <li>Keywords</li>
                        <li>Reserved words</li>
                        <li>Operators</li>
                        <li>Objects</li>
                    </ul>
                </section>
                <section>
                    <h3>DOM</h3>
                    <p>The Document Object Model (DOM) is an application programming interface (API) for XML that was extended for use in HTML. The DOM maps out an entire page as a hierarchy of nodes. Each part of an HTML or XML page is a type of a node containing different kinds of data.</p>
                    <a title="By Birger Eriksson (Own work) [CC BY-SA 3.0 (http://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons" href="http://commons.wikimedia.org/wiki/File%3ADOM-model.svg"><img alt="DOM-model" src="images/document-object-model.png" />
                    </a>
                </section>
                <section>
                    <h3>DOM Levels</h3>
                    <ul>
                        <li>DOM level 1 (DOM Core, DOM HTML)</li>
                        <li>DOM level 2 (DOM Views, DOM Events, DOM Style, DOM Traversal and Range)</li>
                        <li>DOM level 3 (DOM Load and Save, DOM Validation)</li>
                    </ul>
                    <a href="http://en.wikipedia.org/wiki/Comparison_of_web_browsers"><img src="images/browser-dom-support.png" alt="browser dom support">
                    </a>

                </section>
                <section>
                    <h3>BOM</h3>
                    <p>Primarily, the BOM deals with the browser window and frames, but generally any browser - specific extension to JavaScript is considered to be a part of the BOM. The following are some such extensions:</p>
                    <ul>
                        <li>The capability to pop up new browser windows</li>
                        <li>The capability to move, resize, and close browser windows</li>
                        <li>The navigator object, which provides detailed information about the browser</li>
                        <li>The location object, which gives detailed information about the page loaded in the browser</li>
                        <li>The screen object, which gives detailed information about the user’s screen resolution</li>
                        <li>Support for cookies</li>
                        <li>Custom objects such as XMLHttpRequest and Internet Explorer’s ActiveXObject</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Core Concept</h2>
                </section>
                <section>
                    <h3>Primitive and Reference Values</h3>
                    <ul>
                        <li>Primitive values (ndefined, Null, Boolean, Number, and String) are simple pieces of data that are stored in memory on the stack , which is to say that the value is completely stored in one memory location.</li>
                        <li>Reference values , on the other hand, are objects that are stored on the heap , meaning that the value stored in the variable is actually just a pointer to another memory location where the object is stored.</li>
                    </ul>
                    <img src="images/reference-value-type-memory.png" alt="value type and reference type memory">
                </section>
                <section>
                    <h3>Dynamic Properties</h3>
                    <p>When working with reference values, properties and methods may be added, changed, or deleted at any time.</p>
                    <pre><code>var person = new Object();
person.name = "Nicholas";
alert(person.name); //"Nicholas"
</code></pre>
                    <p>Primitive values can’t have properties added to them even though attempting to do so won’t cause an error.
                    </p>
                    <pre><code>var name = "Nicholas";
name.age = 27;
alert(name.age); //undefined
</code></pre>
                </section>
                <section>
                    <h3>Copying Values</h3>
                    <p>When a primitive value is assigned from one variable to another, the value stored on the stack is created and copied into the location for the new variable.</p>
                    <pre><code>var num1 = 5;
var num2 = num1;</code></pre>
                    <img src="images/stack-copy.png" alt="stack copy">
                </section>
                <section>
                    <p>When a reference value is assigned from one variable to another, the value stored on the stack is also copied into the location for the new variable. The difference is that this value is actually a pointer to an object stored on the heap. Once the operation is complete, two variables point to exactly the same object, so changes to one are reflected on the other</p>
                    <pre><code>var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Nicholas";
alert(obj2.name); //"Nicholas"</code></pre>
                    <img src="images/reference-copy.png" alt="reference copy">
                </section>
                <section>
                    <h3>Argument Passing</h3>
                    <p>All function arguments in ECMAScript are passed by value. This means that the value outside of the function is copied into an argument on the inside of the function the same way a value is copied from one variable to another.</p>
                    <ul>
                        <li>If the value is primitive, then it acts just like a primitive variable copy</li>
                        <li>if the value is a reference, it acts just like a reference variable copy</li>
                    </ul>
                    <pre><code>function addTen(num) {
num += 10;
return num;
}
var count = 20;
var result = addTen(count);
alert(count); //20 - no change
alert(result); //30</code></pre>

                </section>
                <section>
                    <pre><code>function setName(obj) {
obj.name = "Nicholas";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"</code></pre>
                    <pre><code>function setName(obj) {
obj.name = "Nicholas";
obj = new Object();
obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"</code></pre>
                </section>
                <section>
                    <h3>Determining Type</h3>
                    <p>The typeof operator, introduced in the previous chapter, is the best way to determine if a variable is a primitive type.</p>
                    <pre><code>var s = "Nicholas";
var b = true;
var i = 22;
var u;
var n = null;
var o = new Object();
alert(typeof s); //string
alert(typeof i); //number
alert(typeof b); //boolean
alert(typeof u); //undefined
alert(typeof n); //object
alert(typeof o); //object</code></pre>
                    <p>The instanceof operator returns true if the variable is an instance of the given reference type (identified by its constructor function).</p>
                    <pre><code>alert(person instanceof Object); //is the variable person an Object?
alert(colors instanceof Array); //is the variable colors an Array?
alert(pattern instanceof RegExp); //is the variable pattern a RegExp?</code></pre>
                </section>
                <section>
                    <h3>Execution Context</h3>
                    <p>The execution context of a variable or function defines what other data it has access to, as well as how it should behave. Each execution context has an associated variable object upon which all of its defined variables and functions exist. This object is not accessible by code but is used behind the scenes to handle data.</p>
                    <img src="images/execution-context-scope-chain.png" alt="execution context scope chain">
                </section>
                <section>
                    <h3>Scope</h3>
                    <p>When code is executed in a context, a scope chain of variable objects is created. The purpose of the scope chain is to provide ordered access to all variables and functions that an execution context has access to.</p>
                    <pre><code>var color = "blue";
function changeColor(){
    var anotherColor = "red";
    function swapColors(){
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        //color, anotherColor, and tempColor are all accessible here
    }
    //color and anotherColor are accessible here, but not tempColor
    swapColors();
}
//only color is accessible here
changeColor();</code></pre>
                    <img src="images/scope-chain.png" alt="scope chain">
                </section>
                <section>
                    <h3>Scope Chain Augmentation</h3>
                    <p>Even though there are only two types of execution contexts, global and local (function), there are other ways to augment the scope chain.</p>
                    <ul>
                        <li>The catch block in a try - catch statement</li>
                        <li>A with statement</li>
                    </ul>
                    <pre><code>function buildUrl() {
var qs = "?debug=true";
with(location){
    var url = href + qs;
}
return url;
}</code></pre>
                </section>

                <section>
                    <h3>No Block-Level Scopes</h3>
                    <p>JavaScript ’ s lack of block - level scopes is a common source of confusion.</p>
                    <pre><code>for (var i=0; i < 10; i++){
    doSomething(i);
}
alert(i); //10
                    </code></pre>
                </section>
                <section>
                    <h3>Variable Declaration</h3>
                    <ul>
                        <li>When a variable is declared using var, it is automatically added to the most immediate context available.</li>
                        <li>If a variable is initialized without first being declared, it gets added to the global context automatically</li>
                    </ul>
                    <pre><code>function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}
var result = add(10, 20); //30
alert(sum); //30</code></pre>
                    <p style="color:orange">Initializing variables without declaring them is a very common mistake in JavaScript programming and can lead to errors. It’s advisable to always declare variables before initializing them to avoid such issues.</p>
                </section>
                <section>
                    <h3>Identifier Lookup</h3>
                    <pre><code>var color = "blue";
function getColor(){
return color;
}
alert(getColor()); //"blue"</code></pre>
                    <img src="images/identifier-lookup.png" alt="identifier lookup">
                    <p style="color:orange">Variable lookup doesn ’ t come without a price. It ’ s faster to access local variables than global variables because there ’ s no search up the scope chain.</p>
                </section>
                <section>
                    <h3>Event Flow</h3>
                    <p>Event flow describes the order in which events are received on the page, the IE and Netscape development teams came up with an almost exactly opposite concept of event flow.</p>
                    <ul>
                        <li> IE would support an event bubbling flow</li>
                        <li>Netscape Communicator would support an event capturing flow</li>
                    </ul>
                </section>
                <section>
                    <h3>Event Bubbling</h3>
                    <p>The IE event flow is called event bubbling , because an event is said to start at the most specific element (the deepest possible point in the document tree) and then flow upward towards the least specific node (the document).</p>
                    <pre><code>&lt; html &gt;
&lt; head &gt;
&lt; title &gt; Event Bubbling Example &lt; /title &gt;
&lt; /head &gt;
&lt; body &gt;
&lt; div id="myDiv" &gt; Click Me &lt; /div &gt;
&lt; /body &gt;
&lt; /html &gt;</code></pre>
                </section>

                <section>
                    <h3>Event Capturing</h3>
                    <p>The Netscape Communicator team came up with an alternate event flow called event capturing . The theory of event capturing is that the least specific node should receive the event first and the most specific node should receive the event last.</p>
                    <img src="images/event-capturing.png" alt="event capturing">
                </section>
                <section>
                    <h3>DOM Event Flow</h3>
                    <p>The event flow specified by DOM Level 2 Events has three phases: the event capturing phase, at the target, and the event bubbling phase.</p>
                    <img src="images\dom-events.png" alt="dom events">
                </section>
                <section>
                    <h3>Cross-Browser Event Handler</h3>
                    <pre><code>var EventUtil = {
    addHandler: function(element, type, handler){
        if (element.addEventListener){
        element.addEventListener(type, handler, false);
        } else if (element.attachEvent){
        element.attachEvent("on" + type, handler);
        } else {
        element["on" + type] = handler;
        }
    },
    removeHandler: function(element, type, handler){
        if (element.removeEventListener){
        element.removeEventListener(type, handler, false);
        } else if (element.detachEvent){
        element.detachEvent("on" + type, handler);
        } else {
        element["on" + type] = null;
        }
    }
};

var btn = document.getElementById("myBtn");
var handler = function(){
alert("Clicked");
};
EventUtil.addHandler(btn, "click", handler);
//other code here
EventUtil.removeHandler(btn, "click", handler);</code></pre>
                    <img src="images/add-event-listener-browser-support.png" alt="add event listener brower support">
                </section>
                <section>
                    <h3>Prototypes</h3>
                    <ul>
                        <li>Objects in JavaScript are based on prototypes. A prototype is an object that serves as the base of another object, defining and implementing members that a new object must have.</li>
                        <li>Prototype objects are shared amongst all instances of a given object type, and so all instances also share the prototype object’s members. </li>
                        <li>Consequently, objects can have two types of members: instance members (also called "own" members) and prototype members. Instance members exist directly on the object instance itself, whereas prototype members are inherited from the object prototype. </li>
                    </ul>
                </section>
                <section>
                    <pre><code>var book = {    
                title: "High Performance JavaScript",    
                publisher: "Yahoo! Press" 
                };
alert(book.toString());   //"[object Object]"
</code></pre>
                    <img src="images/prototypes.png" alt="javascript prototypes">
                </section>
                <section>
                    <h3>Prototype Chains</h3>
                    <p>The prototype of an object determines the type or types of which it is an instance. By default, all objects are instances of Object and inherit all of the basic methods, such as toString().</p>
                    <pre><code>function Book(title, publisher){    
                    this.title = title;    
                    this.publisher = publisher; }
Book.prototype.sayTitle = function(){    
alert(this.title); 
};
var book1 = new Book("High Performance JavaScript", "Yahoo! Press"); 
var book2 = new Book("JavaScript: The Good Parts", "Yahoo! Press");
alert(book1 instanceof Book);   //true alert(book1 instanceof Object); //true
book1.sayTitle();         //"High Performance JavaScript" 
alert(book1.toString());  //"[object Object]" 
                    </code></pre>
                    <img src="images/prototype-chain.png" alt="prototype chain">
                </section>
            </section>
            <section>
                <section>
                    <h2> Core JavaScript pitfalls</h2>
                </section>
                <section>
                    <h3> Avoid using eval or the Function constructor</h3>
                    <ul>
                        <li>Using eval or Function constructor are expensive operations as each time they are called script engine must convert source code to executable code.</li>
                        <li>Additionally, using eval the context of the string has to be interpreted at runtime.</li>
                    </ul>
                    <p>Slow:</p><pre><code>function addMethod(object, property, code) {
    object[property] = new Function(code);
}
addMethod(myObj, 'methodName', 'this.localVar=foo');</code></pre>
                    <p>Faster:</p><pre><code>function addMethod(object, property, func) {
    object[property] = func;
}
addMethod(myObj, 'methodName', function () { 'this.localVar=foo'; });</code></pre>
                </section>
                <section>
                    <h3> Avoid using with</h3>
                    <p>Although seen as a convenience, with construct introduces an extra scope to search each time variable is referenced and the contents of that scope is not known at compile time.</p>
                    <p>Slow:</p><pre><code>with (test.object) {
    foo = 'Value of foo property of object';
    bar = 'Value of bar property of object';
}</code></pre>
                    <p>Faster:</p><pre><code>var myObj = test.object;
myObj.foo = 'Value of foo property of object';
myObj.bar = 'Value of bar property of object';</code></pre>
                </section>
                <section>
                    <h3> Don't use try-catch-finally inside performance-critical functions</h3>
                    <ul>
                        <li>The try-catch-finally construct creates a new variable in the current scope at runtime each time the catch clause is executed where the caught exception object is assigned to a variable.</li>
                        <li>Exception handling should be done at as high level in the script where it does not occur frequently, for example outside a loop.</li>
                        <li>Or if possible, avoid try-catch-finally completely</li>
                    </ul>
                </section>
                <section>
                    <p>Slow: </p><pre><code>
var object = ['foo', 'bar'], i;
for (i = 0; i &lt; object.length; i++) {
   try {
      // do something that throws an exception
   } catch (e) {
      // handle exception
   }
}</code></pre>
                    <p>Faster:</p><pre><code>var object = ['foo', 'bar'], i;
try {
    for (i = 0; i &lt; object.length; i++) {
        // do something
    }
} catch (e) {
    // handle exception
}</code></pre>
                </section>
                <section>
                    <h3> Avoid using global variables</h3>
                    <ul>
                        <li>If you reference global variables from within function or another scope, scripting engine has to look through the scope to find them.</li>
                        <li>Variable in the global scope persist though the life time of the script, whereas in local scope they are destroyed when the local scope is lost.</li>
                    </ul>
                    <p>Slow:</p><pre><code>var i,
    str = '';
function globalScope() {
    for (i=0; i &lt; 100; i++) {
        str += i; // here we reference i and str in global scope which is slow
    }
}
globalScope();</code></pre>
                    <p>Faster:</p><pre><code>function localScope() {
    var i,
        str = '';
    for (i=0; i &lt; 100; i++) {
        str += i; // i and str in local scope which is faster
    }
}
localScope();</code></pre>
                </section>
                <section>
                    <h3> Avoid for-in in performance-critical functions</h3>
                    <ul>
                        <li>The for-in loop requires the script engine to build a list of all the enumerable properties and check for duplicates prior the start.</li>
                        <li>If your code inside for loop does not modify the array it iterates pre-compute the length of the array into a variable <b>len</b> inside for loop scope.</li>
                    </ul>
                    <p>Slow:</p><pre><code>var sum = 0;
for (var i in arr) {
   sum += arr[i];
}</code></pre>
                    <p>

                        Faster:</p><pre><code>var sum = 0;
for (var i = 0, len = arr.length; i &lt; len; i++) {
   sum += arr[i];
}</code></pre>
                </section>
                <section>
                    <h3> Use strings accumulator-style</h3>
                    <ul>
                        <li>Using + operator a new string is created in memory and the concatenated value is assigned to it. Only after this the result is assigned to a variable.</li>
                        <li>To avoid the intermediate variable for concatenation result, you can directly assign the result using += operator.</li>
                    </ul>
                    <p>Slow:</p><pre><code>a += 'x' + 'y';</code></pre>
                    <p>Faster:</p><pre><code>a += 'x';
a += 'y';</code></pre>
                </section>
                <section>
                    <h3> Primitive operations can be faster than function calls </h3>
                    <ul>
                        <li>Consider using alternative primitive operation over function calls in performance critical loops and functions.</li>
                    </ul>
                    <p>Slow:</p><pre><code>var min = Math.min(a, b);
arr.push(val);</code></pre>
                    <p>Faster:</p><pre><code>var min = a &lt; b ? a : b;
arr[arr.length] = val;</code></pre>
                </section>
                <section>
                    <h3> Pass functions, not strings, to setTimeout() and setInterval() </h3>
                    <ul>
                        <li>If you pass a string into setTimeout() or setInterval() the string will be evaluated the same way as with eval which is slow.</li>
                        <li>Wrap your code into an anonymous function instead so that it can be interpreted and optimized during compilation.</li>
                    </ul>
                    <p>Slow:</p><pre><code>setInterval('doSomethingPeriodically()', 1000);
setTimeOut('doSomethingAfterFiveSeconds()', 5000);</code></pre>
                    <p>Faster:</p><pre><code>setInterval(doSomethingPeriodically, 1000);
setTimeOut(doSomethingAfterFiveSeconds, 5000);</code></pre>
                </section>
                <section>
                    <h3> Avoid unnecessary DOM references in objects</h3>
                    <ul>
                        <li> Dont do this :</li>
                    </ul><pre><code>var car = new Object();
car.color = "red";
car.type = "sedan"</code></pre>
                    <ul>
                        <li> Better way would be:</li>
                    </ul><pre><code>var car = {
 color : "red";
 type : "sedan"
}</code></pre>

                </section>
                <section>
                    <h3> Maximize object resolution speed and minimize scope chain</h3>
                    <ul>
                        <li> Inefficient way:</li>
                    </ul><pre><code>var url = location.href;</code></pre>

                    <ul>
                        <li> Efficient one:</li>
                    </ul><pre><code>var url = window.location.href;</code></pre>

                </section>
                <section>
                    <h3> Try to keep script comments to a minimum/ Avoid long variable names</h3>
                    <p>Keep script comments to a minimun or avoid them altogether, especially inside functions, loops and arrays. Comments unnecessarily slow down script execution and increase file size. For example,</p>
                    <ul>
                        <li> Bad Idea :</li>
                    </ul><pre><code>function someFunction()
{
var person_full_name="somename"; /* stores the full name*/
 
}</code></pre>
                    <ul>
                        <li> Better way:</li>
                    </ul><pre><code>function someFunction()
{
var name="somename";
}</code></pre>
                </section>
                <section>
                    <h3> Store local references to out-of-scope variables</h3>
                    <ul>
                        <li>When a function is executed an execution context is created and an activation object containing all local variables is pushed to the front of the context's scope chain.</li>
                        <li>Further in the chain, the slower the identifier resolution is, which means local variables are fastest.</li>
                        <li>By storing local references to frequently used out-of-scope variables reading and writing to variables is significantly faster. This is visible especially with global variables and other deep searches for identifier resolution.</li>
                        <li>Also in-scope variables (var myVar) are faster than object property access (this.myVar).</li>
                    </ul>
                </section>
                <section>
                    <p>Slow:</p><pre><code>function doSomething(text) {
    var divs = document.getElementsByTagName('div'),
        text = ['foo', /* ... n ... */, 'bar'];
    for (var i = 0, l = divs.length; i &lt; l; i++) {
        divs[i].innerHTML = text[i];
    }
}</code></pre>
                    <p>Faster:</p><pre><code>function doSomethingFaster(text) {
    var doc = document,
        divs = doc.getElementsByTagName('div'),
        text = ['foo', /* ... n ... */, 'bar'];
    for (var i = 0, l = divs.length; i &lt; l; i++) {
        divs[i].innerHTML = text[i];
    }
}</code></pre>
                    <p>If you need to access an element (e.g. the head) inside a big loop using a localized DOM access ( get in the example) is faster.</p>
                    <p>Faster:</p><pre><code>function doSomethingElseFaster() {
    var get = document.getElementsByTagName;
    for (var i = 0, i &lt; 100000; i++) {
       get('head');
    }
}</code></pre>
                </section>
                <section>
                    <h3>  Caching values to variables </h3>
                    <ul>
                        <li> Caching values to local variables where ever needed prevents interpreter from doing the repetative job.</li>
                    </ul>
                    <ul>
                        <li> Couple of examples below should clarify the caching/storing values to variable in broader sense.</li>
                    </ul>

                    <p> Example 1) Caching math functions in variables before executing calculations within a loop</p>
                    <p>Wrong Way:</p><pre><code>var d=35;
for (var i=0; i&lt;1000; i++) { 
  y += Math.sin(d)*10; 
}</code></pre>
                    <p>

                        Better Approach:</p><pre><code>var d = 55;
var math_sind = Math.sin(d)*10;
for (var i=0; i&lt;1000; i++) {
  y += math_sind; 
}</code></pre>
                </section>
                <section>
                    <p> Example 2) Caching/Storing array length when used in loops</p>
                    <p>Bad Approach:</p>
                    <p>The length of the array arr is recalculated every time the loop iterates.</p><pre><code>for (var i = 0; i &lt; arr.length; i++) {
    // do something
}</code></pre>
                    <p>Better Approach:</p>
                    <p>Better way is to to cache the length of the array:</p><pre><code>for (var i = 0, len = arr.length; i &lt; len; i++) {
    // do something
}</code></pre>
                    <p> In General we should avoid sending the interpreter out to do unnecessary work once it has already done it once, eg: figuring out the scope chain or the function evaulation values of an expression used more than once.<b>storing/caching values to variable only makes sense if those values are used repetatively or more than once, otherwise we are creating overhead again for declaring a variable, assigning values and then just using only once, so keep in mind</b>
                    </p>

                </section>
            </section>
            <section>
                <section>
                    <h2> Tips for better loading performance</h2>
                </section>
                <section>
                    <h3> Load scripts without blocking for faster startup and to show a splash screen</h3>
                    <ul>
                        <li>When &lt;script&gt; tags are found in the HTML document the referenced script resources are downloaded and executed before the rendering engine can continue to download other resources which effectively blocks the rendering of the page below the tag. To avoid this blocking behaviour a script tag can be created via a mechanism known as a dynamic script tag injection.</li>
                        <li>This mechanism allows the rendering engine to immediately render and display the initial view (aka the splash screen) defined in HTML while the JavaScript resources are still being loaded and executed which leads to better user experience.</li>
                    </ul>
                </section>
                <section>
                    <p>Slow:</p><pre><code>&lt;<a href="http://december.com/html/4/element/div.html">div</a> id="splash"/&gt;
&lt;<a href="http://december.com/html/4/element/script.html">script</a> src="my-script-file.js" type="text/javascript"&gt;&lt;/<a href="http://december.com/html/4/element/script.html">script</a>&gt;</code></pre>
                    <p>Faster:</p><pre><code>&lt;<a href="http://december.com/html/4/element/div.html">div</a> id="splash"/&gt;</code></pre><pre><code>// JavaScript
function loadScript(src, callback) {
    var head = document.getElementsByTagName('head')[0],
        script = document.createElement('script');
    done = false;
    script.setAttribute('src', src);
    script.setAttribute('type', 'text/javascript');
    script.setAttribute('charset', 'utf-8');
    script.onload = script.onreadstatechange = function() {
        if (!done &amp;&amp; (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete')) {
            done = true;
            script.onload = script.onreadystatechange = null;
                if (callback) {
                    callback();
                }
            }
    }
    head.insertBefore(script, head.firstChild);
}
 
// load the my-script-file.js and display an alert dialog once the script has been loaded
loadScript('my-script-file.js', function() { alert('my-script-file.js loaded.'); });</code></pre>
                </section>
                <section>
                    <p>Sources:</p>
                    <ul>
                        <li><a href="http://www.nczonline.net/blog/2009/07/28/the-best-way-to-load-external-javascript/" rel="nofollow">The best way to load external JavaScript</a>
                        </li>
                        <li><a href="http://docs.dojocampus.org/dojo/require" rel="nofollow">Dojo require</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Add an Expires or a Cache-Control HTTP header </h3>
                    <p>Using Apache the Expires HTTP header and the max-age directive of the Cache-Control HTTP header in server responses can be configures in .htaccess. The syntax is as follows:</p>
                    <p>ExpiresDefault "&lt;base&gt; [plus] {&lt;num&gt; &lt;type&gt;}*" ExpiresByType type/encoding "&lt;base&gt; [plus] {&lt;num&gt; &lt;type&gt;}*"</p>
                    <p>Example: ExpiresActive On ExpiresByType image/png "access plus 1 year"</p>
                    <p>Source:
                        <a href="http://httpd.apache.org/docs/2.2/mod/mod_expires.html" rel="nofollow">Apache mod_expires</a>
                    </p>
                </section>
                <section>
                    <h3> Gzip JavaScript and CSS resources </h3>
                    <p>Below is a simple configuration to gzip not only JavaScript and CSS but also HTML, XML and JSON. To accomplish this, the following must be set in the Apache .htaccess:</p>
                    <p>AddOutputFilterByType DEFLATE text/html text/css text/plain text/xml application/x-javascript application/json</p>
                    <p>Source:</p>
                    <ul>
                        <li><a href="http://httpd.apache.org/docs/2.0/mod/mod_deflate.html" rel="nofollow">Apache mod_deflate</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Use YUI Compressor or JSMin to compress the code</h3>
                    <ul>
                        <li>The Best: <a href="http://developer.yahoo.com/yui/compressor/" rel="nofollow">YUI Compressor</a> provides the best overall performance when you consider it as: Total_Speed = Time_to_Download + Time_to_Evaluate. Depends on Rhino and is not applicable for real-time compression.</li>
                        <li>Simple: <a href="http://www.crockford.com/javascript/jsmin.html" rel="nofollow">JSMin</a> has implementations in nearly all the languages and is applicable for real-time compression. After gzipping the size comes very close to that of YUI Compressor.</li>
                        <li>JSMin or YUI Compressor + gzipping is better performer than Dean Edwards' <a href="http://dean.edwards.name/packer/" rel="nofollow">Packer</a> + gzipping. Although Packer provides the smallest (byte-size) code it will evaluate much slower as the scripts are unpacked on the client-side using one pass of a RegExp? this introduces an overhead especially significant on slow mobile devices.</li>
                    </ul>
                </section>
                <section>
                    <p>Sources</p>
                    <ul>
                        <li><a href="http://ejohn.org/blog/library-loading-speed/" rel="nofollow">Library Loading Speed</a>
                        </li>
                        <li><a href="http://www.julienlecomte.net/blog/2007/08/13/" rel="nofollow">Gzip Your Minified JavaScript Files</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Minimize the number and size of resources </h3>
                    <ul>
                        <li>Concatenate multiple scripts into one. However, consider that some mobile browsers have limits in how big resources they keep in cache.</li>
                        <li>Always aim for the smallest code size prior to minification and re-factor to increase re-usable code, consider all resources: HTML, JavaScript, CSS, images, JSON loaded using XHR.</li>
                        <li>Minimize the number of resources per host to enable more efficient parallel loading of resources</li>
                        <li>Serve your content from different hosts to overcode HTTP/1.1 limitation of parallel loading of two resources per host.</li>
                    </ul>
                </section>
                <section>
                    <h3> Load scripts without blocking parallel downloads </h3>
                    <ul>
                        <li>Multiple scripts can be loaded in parallel without blocking using techniques such as via normal script src, XHR eval, XHR injection, script in iframe, script DOM element, script defer and document.write script tag.</li>
                        <li>Depending on your specific constraints (resources in the same/different domain, need to preserve script loading order, need to show browser loading indicator) you can do an informed decision by checking the decision tree in the following presentation (slide 26).</li>
                    </ul>
                    <p><a href="http://www.stevesouders.com/blog/2009/03/16/sxsw-slides/" rel="nofollow">Even Faster Websites - Steve Souders at SXSW ‘09</a>
                    </p>
                </section>
                <section>
                    <h3> Couple asynchronous scripts </h3>
                    <ul>
                        <li>If you have inline script which depend on the script you have multiple options: hardcoded callback, window.onload, timer, degrading script tags and script onload.</li>
                        <li>See slide 35 onwards for details:</li>
                    </ul>
                    <p><a href="http://www.stevesouders.com/blog/2009/03/16/sxsw-slides/" rel="nofollow">Even Faster Websites- Steve Souders at SXSW ‘09</a>
                    </p>
                </section>
                <section>
                    <h3> Move inline scripts above stylesheets </h3>
                    <ul>
                        <li>Browsers download stylesheets in parallel with other resources that follow unless the stylesheet is followed by an inline script.</li>
                        <li>Workaround is to either avoid inline scripts or move them above stylesheets or below other resources (e.g. images, scripts) and use &lt;link&gt;, not @import.</li>
                        <li><a href="http://stevesouders.com/cuzillion/?ex=10021" rel="nofollow">Live demo</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Use iframes sparingly </h3>
                    <ul>
                        <li>Parent's onload doesn't fire until iframe and all its components are downloaded.</li>
                        <li>Workaround for Safari and Chrome is to set iframe src in JavaScript.</li>
                        <li>Scripts and stylesheets also block iframe from loading.
                            <ul>
                                <li>In IE and FF stylesheets in the parent block the iframe or its resources</li>
                            </ul>
                        </li>
                        <li>iframe shares connection pool with parent, typically 2 connections per host.</li>
                    </ul>
                    <ul>
                        <li>In IE and FF stylesheets in the parent block the iframe or its resources</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2> Document Object Model (DOM) obscurities </h2>
                </section>
                <section>
                    <h3> Minimize the size of the DOM </h3>
                    <p>Slow DOM performance can be traced back into the following three main causes:</p>
                    <ul>
                        <li>The size of DOM slows down all the operation related to it such as reflowing, traversal and DOM manipulation.</li>
                        <li>The most effective way to make programs faster is to make n smaller means that the DOM should be as small as possible at all times.</li>
                        <li>Minimize n, you can track the number of elements in a page by:
                </section>
                <section>
                    <h3> Use document fragment templates for re-usability </h3>
                    <ul>
                        <li>Dynamically inserting and updating elements into the DOM is expensive. An efficient way to tackle this is to use HTML templates which can be cloned and re-used for re-usable parts of the DOM such as dialogs and other UI widgets.</li>
                        <li>In practice the approach is to modify, clone and append all nodes in JavaScript without touching the live DOM and append the completed document fragment to the DOM at once. One can do this with DOM API or alternatively construct a string representation of the HTML fragment to append based on a string template and push that into the DOM with a one innerHTML assignment. On both cases the rendering engine does not have to reflow and repaint the layout multiple times. Next we introduce some techniques to achieve this behavior.</li>
                    </ul>
                </section>
                <section>
                    <h3> Minimize the number of reflows and repaints </h3>
                    <ul>
                        <li>Operation that trigger reflows should be used sparsely.</li>
                        <li>Reflowing a table element is more expensive that reflowing equivalent element with block display.</li>
                        <li>Elements that are positioned absolutely or fixed do not affect the main document layout, so their reflowing is cheaper as they do not trigger main document reflowing. This is recommended approach for element that need to be animated.</li>
                        <li>DOM modifications trigger reflow. This means that operations such as adding new elements, changing the value of text nodes or adding element attributes and their properties cause reflow.</li>
                        <li>Good strategies to overcome this limitation are elaborated next.</li>
                    </ul>
                </section>
                <section>
                    <h4> Use createDocumentFragment() </h4>
                    <ul>
                        <li>Make multiple changes in a DOMDocumentFragment and add the fragment into the DOM in a single operation. This triggers only one reflow.</li>
                    </ul>
                    <p>Slow:</p><pre><code>var list = ['foo', 'bar', 'baz'],
    elem,
    contents;
for (var i = 0; i &lt; list.length; i++) {
    elem = document.createElement('div');
    content = document.createTextNode(list[i]);
    elem.appendChild(content);
    document.body.appendChild(elem);
}</code></pre>
                    <p>Faster:</p><pre><code>var fragment = document.createDocumentFragment(),
    list = ['foo', 'bar', 'baz'],
    elem,
    contents;
for (var i = 0; i &lt; list.length; i++) {
    elem = document.createElement('div');
    content = document.createTextNode(list[i]);
    fragment.appendChild(content);
}
document.body.appendChild(fragment);</code></pre>
                </section>
                <section>
                    <h4> Use cloneNode() </h4>
                    <ul>
                        <li>If you're not working on elements that do not contain form elements or event handlers, you can clone the element to modify and swap it in place after all the changes have been done resulting in a one reflow only.</li>
                        <li>A faster alternative to above slow approach is presented below.</li>
                    </ul>
                    <p>Faster:</p><pre><code>var orig = document.getElementById('container'),
    clone = orig.cloneNode(true),
    list = ['foo', 'bar', 'baz'],
    elem,
    contents;
clone.setAttribute('width', '50%');
for (var i = 0; i &lt; list.length; i++) {
    elem = document.createElement('div');
    content = document.createTextNode(list[i]);
    elem.appendChild(content);
    clone.appendChild(elem);
}
original.parentNode.replaceChild(clone, original);</code></pre>
                </section>
                <section>
                    <h4> Use HTML templates and innerHTML </h4>
                    <ul>
                        <li>One way to implement a templating system is to populate template content based on a light-weight JavaScript object acting as a date model. The data model may be persisted as JSON serialization into e.g. <a href="http://www.developer.nokia.com/Resources/Library/Web/" rel="nofollow">setPreferenceForKey()</a> store in S60 WRT, in a HTTP cookie or XHR'd to the server-side.</li>
                    </ul><pre><code>&lt;nowiki&gt;
var model = { title: 'My Test Page'; },
    template = [];
template.push('&lt;h1&gt;' + model.title + '&lt;h1&gt;');
template.push('&lt;div&gt;Another Test Element&lt;div&gt;');
document.getElementById(containerId).innerHTML = template.join(''); 
// alternatively you can use concat() -- see string concatenation test results
&lt;/nowiki&gt;</code></pre>
                </section>
                <section>
                    <h4> Modify an invisible element </h4>
                    <ul>
                        <li>If the display property of an element is set to none it will not be repainted.</li>
                        <li>By setting display to none, do the modifications and then set it to block causes only two reflows</li>
                    </ul>
                    <p>Slow:</p><pre><code>var subElem = document.createElement('div'),
    elem = document.getElementById('animated');
elem.appendChild(subElem);
elem.style.width = '320px';</code></pre>
                    <p>Faster:</p><pre><code>var subElem = document.createElement('div'),
    elem = document.getElementById('animated');
elem.style.display = 'none';
elem.appendChild(subElem);
elem.style.width = '320px';
elem.style.display = 'block';</code></pre>
                </section>
                <section>
                    <h4> Minimize the use of operations determining the dimensions or location of elements </h4>
                    <ul>
                        <li>Determining dimensions or location of elements via getComputedStyle, offsetWidth, scrollWidth and clientWidth properties will force reflow.</li>
                        <li>If you take the measurements repeatedly, consider taking them only once.</li>
                        <li>This issue is the main cause of slowness in WebKit according to <a href="http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/#comment-13157" rel="nofollow">Dave Hyatt</a>
                        </li>
                    </ul>
                    <p>Slow:</p><pre><code>var elem = document.getElementById('animated');
elem.style.fontSize = (elem.offsetWidth / 10) + 'px';
elem.firstChild.style.marginleft = (elem.offsetWidth / 20) + 'px';</code></pre>
                    <p>Faster:</p><pre><code>var elem = document.getElementById('animated'),
    elemWidth = elem.offsetWidth;
elem.style.fontSize = (elemWidth / 10) + 'px';
elem.firstChild.style.marginleft = (elemWidth / 20) + 'px';</code></pre>
                </section>
                <section>
                    <h4> Make multiple predefined style changes at once using className </h4>
                    <ul>
                        <li>As with DOM manipulation, several style changes can be done at the same time.</li>
                        <li>Instead if you set the styles one by one, multiple reflows and repaints can be triggered.</li>
                    </ul>
                    <p>Slow:</p><pre><code>var elem = document.getElementById('styled');
elem.style.background = 'blue';
elem.style.color = 'white';
 
Faster: 
&lt;code html4strict&gt;
&lt;style type="text/css"&gt;
div { background: white; color: black; }
div.active { background: blue; color: white; }
&lt;/style&gt;
...</code></pre><pre><code>var elem = document.getElementById('styled').className = 'active';</code></pre>
                </section>
                <section>
                    <h4> Make multiple dynamic style changes at once using setAttribute </h4>
                    <ul>
                        <li>For dynamic animation, using predefined styles does not work. In this case setAttribute object can be used (for IE, use style.cssText property)</li>
                    </ul>
                    <p>Faster:</p><pre><code>var elem = document.getElementById('styled');
elemStyle = 'background: blue; color: white;';
elem.setAttribute('style', elemStyle);</code></pre>

                </section>
                <section>
                    <h4> CSS class name vs. style property changing </h4>
                    <p>Changing the class name of an element is a nice way to use JavaScript to dynamically change elements. Performance varies from browser to browser, but generally it is faster to change an element's visual appearance directly via the Javascript style attribute, rather than to change a class name on that element.</p>
                    <p>Slow: </p><pre><code>div.active { border: 1px solid red; }</code></pre>
                    <p>Faster (for a one element):</p><pre><code>var container = document.getElementById('container');
container.style.border = '1px solid red';</code></pre>
                </section>
                <section>
                    <p>The above method appears to be more efficient when changing a specific number of items. Sometimes a single class name change is effective however. If you need to change all elements under a given container for example, it is more efficient to change the class name of a parent container which holds the affected elements and let CSS do what it does best.</p>
                    <p>Faster (if multiple child elements of a container need to be changed): // by changing the class name of the container, all of its child div elements will be updated #container.active div { border: 1px solid red; }</p>
                    <p>Depending on the specific case at hand you should use the method which gives you the best performance (without sacrificing too much of the separation of concerns benefits of externally defined CSS).</p>
                    <p>Source:</p>
                    <ul>
                        <li><a href="http://www.schillmania.com/content/entries/2009/yahoo-photos-frontend-thoughts/" rel="nofollow">A Snapshot of The Yahoo! Photos Beta - Web Development Perspective</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Avoid traversing large number of nodes </h3>
                    <ul>
                        <li>Always try to use inbuilt methods and collections of the DOM to narrow down the search to smallest number of nodes possible.</li>
                        <li>Try to avoid manually recursively stepping through the DOM as much as possible.</li>
                    </ul>

                    <p>Slow:</p><pre><code>var elements = document.getElementsByTagName('*'); // searches every element, slow
for (i = 0; i &lt; elements.length; i++) {
    if (element[i].hasAttribute('selected')) { // continues even through element was found
        ...
    }
}</code></pre>
                    <p>Faster:</p><pre><code>var elements = document.getElementById('parent').childNodes; // we know the element is a child of parent
for (i = 0; i &lt; elements.length; i++) {
    if (element[i].nodeType == 1 &amp;&amp; element[i].hasAttribute('selected') { // first test for valid node type
        ...
        break; // break out of the loop if we found what we were looking for
    }
}</code></pre>
                </section>
                <section>
                    <h3> Avoid modifications while traversing</h3>
                    <ul>
                        <li>childNodes and NodeList returned by getElementsByTagName() are live. This means that these collections may change without waiting for the execution to finish first.</li>
                        <li>If new elements are added to the collections while they are traversed, an infinite loop may occur.</li>
                        <li>If new elements are added even outside of collection itself, the collection must look for potential new entries. Due to this it cannot remember its last position or length which need to be recalculated.</li>
                    </ul>
                </section>
                <section>
                    <p>Slow:</p><pre><code>var elems = document.getElementsByTagName('div');
for (var i = 0; i &lt; elems.length; i++) {
    elems[i].appendChild(document.createTextNode(i));
}</code></pre>
                    <p>Faster:</p><pre><code>var elems = document.getElementsByTagName('div'),
    temp = [];
for (var i = 0; i &lt; elems.length; i++) {
    temp[i] = elems[i]; // first a build static list of elements to modify
}
for (var i = 0; i &lt; temp.length; i++) {
    temp[i].appendChild(document.createTextNode(i)); // perform modifications on static list instead of live NodeList
}
temp = null;</code></pre>
                </section>
                <section>
                    <h3> Cache DOM values into variables </h3>
                    <ul>
                        <li>Cache frequently accessed DOM values into variables.</li>
                    </ul>
                    <p>Slow:</p><pre><code>document.getElementById('elem').propertyOne = 'value of first property';
document.getElementById('elem').propertyTwo = 'value of second property';
document.getElementById('elem').propertyThree = 'value of third property';</code></pre>
                    <p>Faster:</p><pre><code>var elem = document.getElementById('elem').propertyOne = 'value of first property';
elem.propertyTwo = 'value of second property';
elem.propertyThree = 'value of third property'</code></pre>
                </section>
                <section>
                    <h3> Remove references to documents that have been closed</h3>
                    <ul>
                        <li>If a reference to frame, iframe or object is stored in a global variable or a property, clear it by setting it to null or deleting it.</li>
                        <li>For example, a popup window that is closed and has a reference to global variable, will be kept in memory although the document itself is no longer loaded, if it is not deleted manually.</li>
                    </ul>
                </section>
                <section>
                    <p>Slow:</p><pre><code>var frame = parent.frames['frameId'].document,
    container = frame.getElementById('contentId'),
    content = frame.createElement('div');
content.appendChild(frame.createTextNode('Some content'));
container.appendChild(content);</code></pre>
                    <p>Faster:</p><pre><code>var frame = parent.frames['frameId'].document,
    container = frame.getElementById('contentId'),
    content = frame.createElement('div');
content.appendChild(frame.createTextNode('Some content'));
container.appendChild(content);
// nullify references to frame
frame = null;
container = null;
content = null;</code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2> Object-Oriented JavaScript </h2>
                </section>
                <section>
                    <h3> Consider alternative inheritance mechanisms </h3>
                    <ul>
                        <li>There exists many ways to mimic Object Orientated style inheritance in JavaScript. However, not all the mechanism to emulate inheritance perform similarly.</li>
                        <li>Especially if your code calls overridden methods frequently you should take a look at the <a href="http://www.broofa.com/2009/02/javascript-inheritance-performance/" rel="nofollow">results of JavaScript Inheritance Performance</a> study.</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2> Client-server communication </h2>
                </section>
                <section>
                    <h3> Set timeouts to XMLHttpRequests </h3>
                    <ul>
                        <li>Browsers will timeout XHR requests after some time, but sometimes it is beneficial to abort the connection under script control. This can be done by adding timeouts to XHR calls using setTimeout().</li>
                    </ul><pre><code>var xhr = new XMLHttpRequest ();
xhr.open('GET', url, false);
xhr.onreadystatechange = function () {
    if (this.readyState == 4) {                    
        clearTimeout(timeout);
        // do something with response data
    }
}
var timeout = setTimeout( 
    function () {
        xhr.abort();
        // call error callback
    },
    60*1000 // timeout after a minute
);
xhr.send();</code></pre>
                </section>
                <section>
                    <h3> Consider using a custom data exchange format for large datasets, as an alternative to XML and JSON</h3>
                    <ul>
                        <li>Depending on the browser, its version and OS, the performance difference between XML or JSON parsing and traversing may be very significant. For example, on Nokia 5800 XpressMusic with a very large dataset JSON is approx. 5x faster.</li>
                        <li>Using a custom string-based data format (think CSV) over XML and JSON is efficient in terms of transferred bytes and parse time with large datasets.</li>
                        <li>Using JavaScript’s String and RegExp methods one can match the speed of JSON executed natively with as little overhead to the file size as possible.</li>
                    </ul>
                </section>
                <section>
                    <p>Equivalent using custom data format and String and RegExp methods:</p><pre><code>that.contacts = o.responseText.split("\\c");
 
for (var n = 0, len = that.contacts.length, contactSplit; n &lt; len; n++) {
 
   contactSplit = that.contacts[n].split("\\a");
 
   that.contacts[n] = {};
   that.contacts[n].n = contactSplit[0];
   that.contacts[n].e = contactSplit[1];
   that.contacts[n].u = contactSplit[2];
   that.contacts[n].r = contactSplit[3];
   that.contacts[n].s = contactSplit[4];
   that.contacts[n].f = contactSplit[5];
   that.contacts[n].a = contactSplit[6];
   that.contacts[n].d = contactSplit[7];
   that.contacts[n].y = contactSplit[8];
}</code></pre>
                    <p>Sources:</p>
                    <ul>
                        <li><a href="http://code.flickr.com/blog/2009/03/18/building-fast-client-side-searches/" rel="nofollow">Building Fast Client-side Searches </a>
                        </li>
                        <li><a href="http://ejohn.org/blog/native-json-support-is-required/" rel="nofollow">Native JSON Support is Required</a>
                        </li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2> Animations </h2>
                </section>
                <section>
                    <h3> Use animations modestly </h3>
                    <ul>
                        <li>Animation without hardware support is slow. Try to avoid excessive use of animations which do not bring any real usability value. At least give users an opportunity to disable animations.</li>
                    </ul>
                </section>
                <section>
                    <h3> Use scrollTo() to animate scrolling </h3>
                    <p>Using native scrolling via scrollTo() performs significantly better as it does not trigger reflow.</p>
                </section>
                <section>
                    <h3> Absolutely or fixed position animated elements </h3>
                    <ul>
                        <li>By default elements have style property position: static and animating such elements causes reflowing of the layout and is expensive.</li>
                        <li>Elements to be animated should be set as position: absolute or position: fixed if reflowing is not mandatory for smoother animation and lesser CPU load. Such elements do not affect other elements layout, so they will only cause a repaint rather than a full reflow with a nice performance boost.</li>
                        <li>CSS positioning schemes for position property:</li>
                    </ul>
                    <p>Source:</p>
                    <ul>
                        <li><a href="http://www.w3schools.com/cssref/pr_class_position.asp" rel="nofollow">w3schools - CSS position Property</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Use one timer to animate multiple elements at the same time </h3>
                    <ul>
                        <li>setTimeout() and setInterval() timers are two basic methods used to implement animation (i.e. trigger changes to element size, position and/or appearance over time).</li>
                        <li>If multiple elements are animated at the same time, the best frame rate is achieved by iterating across all animated elements inside a single loop. Using multiple timers makes animation less efficient and consistent, presumably due to timer invocation overhead.</li>
                    </ul>
                </section>
                <section>
                    <p>Slow:</p><pre><code>setInterval(function() {
    animateFirst(arg);
}, 50);
setInterval(function() {
    animateSecond(arg);
}, 50);
function animateFirst(arg) {};
function animateSecond(arg) {};</code></pre>
                    <p>Faster:</p><pre><code>setInterval(function() {
    animateFirst(arg);
    animateSecond(arg);
}, 50);
function animateFirst(arg) {};
function animateSecond(arg) {};</code></pre>
                    <p>Sources, further reading:</p>
                    <ul>
                        <li><a href="http://www.schillmania.com/content/projects/javascript-animation-1/" rel="nofollow">Javascript Animation: Tutorial, Part 1 </a>
                        </li>
                        <li><a href="http://www.schillmania.com/content/projects/javascript-animation-2/" rel="nofollow">Javascript Animation: Tutorial, Part 2</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Trade animation smoothness for speed</h3>
                    <p>To trade smoothness for speed means that while you may want to move an animation 1 pixel at a time, the animation and subsequent reflows may in that case use 100% of the CPU and the animation will seem jumpy as the browser is forced to drop frames to update the flow. Moving the animated element by e.g. 5 pixels at a time may seem slightly less smooth on faster machines, but won’t cause CPU thrashing that easily on mobile devices.</p>

                </section>
            </section>
            <section>
                <section>
                    <h2> Events </h2>
                </section>
                <section>
                    <h3> Use event delegation </h3>
                    <ul>
                        <li>Assigning event handlers to individual objects can add up quickly and is expensive if you create a lots of new elements dynamically to which event handlers need to be bound.</li>
                        <li>This becomes especially interesting if you assign multiple event listeners (e.g. click and blur to a one element. In case of 100 elements that would mean 200 event handlers.</li>
                        <li>Using DOM Level 2 event model all events propagate toward the document object which is highest up in the hierarchy. This means that one can bind event listeners to document which invokes a controller and passes the event object to it. The controller is responsible for inspecting the internals of the event and dispatching to appropriate logic.</li>
                    </ul>
                </section>
                <section>
                    <p>Slow:</p><pre><code>var elems = [first, ..., last]; // an array which holds say 1000 references to element to which assign the event handlers to
for (var i, l = elems.length; i++; i &lt; l) {
    elems[i].onclick = function() {};
    elems[i].onblur = function() {};
}</code></pre>
                    <p>Faster:</p><pre><code>//HTML
&lt;button id="doSomething"&gt;Click me to do something&lt;/button&gt; // you can add more of elements without the need to worry about binding event handlers
 
// JS
document.addEventListener('click', function(event) { eventController(event); }, false);
document.addEventListener('blue', function(event) { eventController(event); }, false);
 
function eventController(event) {
   // inspect the event object internals and do something wise
   if (event.target.id === 'doSomething') {
      doSomething();   
   }
}
 
function doSomething() {}</code></pre>
                </section>
                <section>
                    <h3> Throttle event handlers which fire excessively </h3>
                    <ul>
                        <li>If a handler is called many times, the responsiveness of the UI degrade and tops the CPU. This is especially an issue if the event handler triggers reflow as is the case with resize.</li>
                        <li>On S60 5.0 devices input element's blur handler is called each time the content of the input field changes, e.g. user types in a single letter.</li>
                        <li>You may want your function to run once after the last event has fired to prevent excessive calls to potentially expensive functions. You must implement throttling mechanism to achieve that kind of a rate limited.</li>
                    </ul>
                </section>
                <section>
                    <p>Slow:</p><pre><code>window.onresize = resizeHandler; // fires excessively during resize</code></pre>
                    <p>Faster:</p><pre><code>function SomeObject() {
     var self = this;
     this.lastExecThrottle = 500; // limit to one call every "n" msec
     this.lastExec = new Date();
     this.timer = null;
     this.resizeHandler = function() {
         var d = new Date();
         if (d-self.lastExec &lt; self.lastExecThrottle) {
             // This function has been called "too soon," before the allowed "rate" of twice per second
             // Set (or reset) timer so the throttled handler execution happens "n" msec from now instead
             if (self.timer) {
                 window.clearTimeout(self.timer);
             }
             self.timer = window.setTimeout(self.resizeHandler, self.lastExecThrottle);
             return false; // exit
        }
        self.lastExec = d; // update "last exec" time
        // At this point, actual handler code can be called (update positions, resize elements etc.)
        // self.callResizeHandlerFunctions();
    }
}
 
var someObject = new SomeObject();
window.onresize = someObject.resizeHandler;</code></pre>
                    <p>Source:</p>
                    <ul>
                        <li><a href="http://www.schillmania.com/content/entries/2009/yahoo-photos-frontend-thoughts/" rel="nofollow">A Snapshot of The Yahoo! Photos Beta - Web Development Perspective</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Escaping the JavaScript call stack with setTimeout</h3>
                    <ul>
                        <li>Setting up handlers that run after an event has fired needs some trickery. Because the event doesn’t take effect until the event-handling call stack opens and closes completely, there’s no way to work in a post-event environment via conventional event handlers.</li>
                        <li>When something is called using setTimeout with a delay of 0 the JavaScript engine notices it is busy (with a task which invoked setTimeout) and queues the setTimeout code for execution immediately after the current call stack closes.</li>
                        <li>This technique can be used to prioritize certain functionality such as showing and hiding loading indicator prior to executing a computationally heavy operation such as modifying the DOM.</li>
                    </ul>
                </section>
                <section>
                    <p>In a typical scenario this will not turn the loading indicator visible:</p><pre><code> showLoadingIndicator();
 doSomethingExpensive();</code></pre>
                    <p>Workaround is to use setTimeout as follows (please take extra care when using this anti-pattern as what it does is actually delays the execution in order to display the loading indicator in the UI):</p><pre><code>function switchViews() {
    setTimeout(function() {
        showLoadingIndicator();
    }, 0);
 
    setTimeout(function() {
        doSomethingExpensive();
    }, 50);
}</code></pre>
                    <p>Source:</p>
                    <ul>
                        <li><a href="http://blog.thinkature.com/index.php/2006/11/26/escaping-the-javascript-call-stack-with-settimeout/" rel="nofollow">Escaping the JavaScript call stack with setTimeout</a>
                        </li>
                    </ul>

                </section>
            </section>
            <section>
                <section>
                    <h2> Styling </h2>
                </section>
                <section>
                    <h3> Optimize CSS </h3>
                    <ul>
                        <li>Create a component library</li>
                        <li>Use consistent semantic styles</li>
                        <li>Design modules to be transparent on the inside</li>
                        <li>Be flexible</li>
                        <li>Learn to love grids</li>
                        <li>Minimize selectors</li>
                        <li>Separate structure and skin</li>
                        <li>Separate container and content</li>
                        <li>Extend objects by applying multiple classes to an element</li>
                        <li>Use reset and fonts from YUI</li>
                        <li>Source: <a href="http://www.slideshare.net/stubbornella/object-oriented-css" rel="nofollow">Object Oriented CSS</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h4> Change CSS classes near the edges of the DOM tree </h4>
                    <p>To limit the scope of the reflow to as few nodes as possible you should avoid changing a class on wrapper (or body) element(s) which affects the display of many child nodes. Additionally, that may result in re-resolving style on the entire document and for a large DOM that could lock up the browser for a while.</p>
                    <p>Source:</p>
                    <ul>
                        <li><a href="http://www.shauninman.com/archive/2008/05/05/css_qualified_selectors#comment_3942" rel="nofollow">Dave Hyatt on CSS Selectors</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h4> Avoid tables for layout or use table-layout: fixed</h4>
                    <p>Avoid tables for layout. As if you needed another reason to avoid them, tables often require multiple passes before the layout is completely established because they are one of the rare cases where elements can affect the display of other elements that came before them on the DOM. Imagine a cell at the end of the table with very wide content that causes the column to be completely resized. This is why tables are not rendered progressively in all browsers and yet another reason why they are a bad idea for layout.</p>
                    <p>It is recommended to use a fixed layout ( table-layout: fixed) for data tables to allow a more efficient layout algorithm. This will allow the table to render row by row according to the CSS 2.1 specification.</p>
                    <p>Source:</p>
                    <ul>
                        <li><a href="http://www.stubbornella.org/content/2009/03/27/reflows-repaints-css-performance-making-your-javascript-slow/" rel="nofollow">Reflows &amp; Repaints: CSS Performance making your JavaScript slow</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h3> Optimize images </h3>
                    <ul>
                        <li>Combine similar colors</li>
                        <li>Avoid whitespace in sprites, use CSS instead</li>
                        <li>Horizontal is better than vertical</li>
                        <li>Limit the number of colors</li>
                        <li>First optimize individual images, next sprites in it</li>
                        <li>Reduce anti-aliased pixels via size and alignment</li>
                        <li>Avoid diagonal gradients due to increased image size</li>
                        <li>Avoid alpha transparency (IE does not support)</li>
                        <li>Change gradient color every 2-3 pixels</li>
                    </ul>
                    <p>Source:</p>
                    <ul>
                        <li>Design Fast Websites <a href="http://www.slideshare.net/stubbornella/designing-fast-websites-presentation" rel="nofollow">slides</a> and <a href="http://video.yahoo.com/" rel="nofollow">presentation</a>
                        </li>
                    </ul>

                </section>
            </section>
            <section>
                <section>

                    <h2> jQuery-specifics </h2>
                    <p>NB! These optimization patterns are aimed at jQuery 1.2.6. Recent versions and the Sizzle selector engine alleviate some of these bottlenecks.</p>
                    <p>Sources
                        <a href="http://ajaxian.com/archives/ajax-experience-talks-resig-slocum-and-heilmann" rel="nofollow">Advanced jQuery with John Resig </a>
                        <a href="http://ejohn.org/blog/function-call-profiling/" rel="nofollow">JavaScript Function Call Profiling </a>
                    </p>
                </section>
                <section>
                    <h3> Minimize the use of slow jQuery methods </h3>
                    <p>remove(), hmtl() and empty() have order of n2 time complexity, that is T(n) = O(n2). Minimizing the use of these methods is recommended in jQuery versions prior to 1.3.3. .</p>
                    <p>The process behind these manipulations methods is the following: cleaning the input string, converting the string into a DOM fragment and injecting it into the DOM.</p>
                </section>
                <section>
                    <h3> Optimize selectors </h3>
                    <p>Pay attention to the selectors you use. E.g. if you want to hide paragraphs which are direct children of div elements there are multiple ways to do it.</p>
                    <p>Using the selector below will try to find all div elements, loops thought all of them and find all p relative to the div, merge and figure out unique results. Making sure that the returned set is unique is where the most time is spent, and is very slow especially with a large DOM tree.</p>
                    <p>Slow:</p><pre><code>$("div p").hide();</code></pre>
                    <p>A one way to optimize the selector is to match direct children of div (this may require you to re-factor the DOM structure of your app and may not be feasible in every scenario). This alternative flatter selector will try to find all div elements, loops thought all child elements and verifies if element is p.</p>
                    <p>Faster:</p><pre><code>$("div &gt; p").hide();</code></pre>
                </section>
                <section>
                    <h3> Consider alternatives to jQuery.each() </h3>
                    <p>Depending on the size of the array, looping through it using {{{1}}} instead of jQuery.each(myArray) may be faster.</p>
                </section>
                <section>
                    <h3> Consider alternatives to .show(), .hide() and .toggle()</h3>
                    <p>Toggling element visibility via .css({'display':'none'}) and .css({'display':'block'}); is faster than using convenience functions .show(), .hide() and toggle(), especially while working with large number of elements. Depending on the rendering engine used, .css() is also faster than using .addClass() and .removeClass().</p>
                    <p>

                        Slow:</p><pre><code>$('#elementToHide').hide();
$('#elementToShow').show();</code></pre>
                    <p>Faster:</p><pre><code>$('#elementToHide').css({'display':'none'});
$('#elementToShow').css({'display':'block'});</code></pre>
                </section>
                <section>
                    <p>For dealing with extremely large set of DOM elements, you may want to consider disabling stylesheets as follows:</p><pre><code>&lt;<a href="http://december.com/html/4/element/style.html">style</a> id="special_hide"&gt;.special_hide { display: none; }&lt;/<a href="http://december.com/html/4/element/style.html">style</a>&gt;
&lt;!--  ...  --&gt;
&lt;<a href="http://december.com/html/4/element/div.html">div</a> class="special_hide"&gt;Special hide DIV&lt;/<a href="http://december.com/html/4/element/div.html">div</a>&gt;</code></pre><pre><code>// show all elements with a class of "special_hide"
$('#special_hide').attr('disabled', 'true');
 
// hide all elements with a class of "special_hide"
$('#special_hide').attr('disabled', 'false');</code></pre>

                </section>
            </section>


            <section>
                <h2>THE END</h2>
                <p>BY <a href="http://browserwork.com/contact.html" target="_blank">Aaron Zhang</a> / <a href="http://browserwork.com">browserwork.com</a>
                </p>
            </section>

        </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [{
            src: 'lib/js/classList.js',
            condition: function() {
                return !document.body.classList;
            }
        }, {
            src: 'plugin/markdown/marked.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/markdown/markdown.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() {
                hljs.initHighlightingOnLoad();
            }
        }, {
            src: 'plugin/zoom-js/zoom.js',
            async: true,
            condition: function() {
                return !!document.body.classList;
            }
        }, {
            src: 'plugin/notes/notes.js',
            async: true,
            condition: function() {
                return !!document.body.classList;
            }
        }]
    });
    </script>

</body>

</html>
