<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>High Performance JavaScript</title>

    <meta name="description" content="JavaScript Performance Best Practices">
    <meta name="author" content="Aaron Zhang">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/serif.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
    if (window.location.search.match(/print-pdf/gi)) {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    }
    </script>

    <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
</head>

<body>

    <div class="reveal">

        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <h1>High Performance JavaScript</h1>
                <h3>JavaScript Performance Best Practices</h3>
                <p>
                    <small><a href="http://browserwork.com/contact.html" target="_blank">Aaron Zhang</a> - <a href="http://www.browserwork.com" target="_blank">Browserwork.com</a>
                    </small>
                </p>
            </section>
            <section>
                <section>
                    <h2>JavaScript Overview</h2>
                </section>
                <section>
                    <h3>JavaScript History</h3>
                    <ul>
                        <li>Beginnings at Netscape</li>
                        <li>Server-side JavaScript</li>
                        <li>Adoption by Microsoft - IE3.0 - 1996</li>
                        <li>Standardization - Ecma - 1997</li>
                        <li>Later developments</li>
                    </ul>
                </section>
                <section>
                    <h3>Features</h3>
                    <ul>
                        <li>Imperative and structured</li>
                        <li>Dynamic</li>
                        <li>Functional</li>
                        <li>Prototype-based</li>
                        <li>Implicit and explicit delegation</li>
                        <li>Miscellaneous</li>
                        <li>Vendor-specific extensions</li>
                    </ul>
                </section>
                <section>
                    <h3>Major Components</h3>
                    <ul>
                        <li>ECMAScript - which is defined in ECMA - 262 and provides the core functionality</li>
                        <li>DOM (Document Object Model) - which provides methods and interfaces for working with the content of a web page</li>
                        <li>BOM (Browser Object Model) - which provides methods and interfaces for interacting with the browser</li>
                    </ul>
                </section>
                <section>
                    <h3>ECMAScript</h3>
                    <p>ECMAScript is the scripting language standardized by Ecma International in the ECMA-262 specification and ISO/IEC 16262. The language is widely used for client-side scripting on the web, in the form of several well-known implementations such as JavaScript, JScript and ActionScript.</p>
                    <ul>
                        <li>Syntax</li>
                        <li>Types</li>
                        <li>Statements</li>
                        <li>Keywords</li>
                        <li>Reserved words</li>
                        <li>Operators</li>
                        <li>Objects</li>
                    </ul>
                </section>
                <section>
                    <h3>DOM</h3>
                    <p>The Document Object Model (DOM) is an application programming interface (API) for XML that was extended for use in HTML. The DOM maps out an entire page as a hierarchy of nodes. Each part of an HTML or XML page is a type of a node containing different kinds of data.</p>
                    <a title="By Birger Eriksson (Own work) [CC BY-SA 3.0 (http://creativecommons.org/licenses/by-sa/3.0)], via Wikimedia Commons" href="http://commons.wikimedia.org/wiki/File%3ADOM-model.svg"><img alt="DOM-model" src="images/document-object-model.png" />
                    </a>
                </section>
                <section>
                    <h3>DOM Levels</h3>
                    <ul>
                        <li>DOM level 1 (DOM Core, DOM HTML)</li>
                        <li>DOM level 2 (DOM Views, DOM Events, DOM Style, DOM Traversal and Range)</li>
                        <li>DOM level 3 (DOM Load and Save, DOM Validation)</li>
                    </ul>
                    <a href="http://en.wikipedia.org/wiki/Comparison_of_web_browsers"><img src="images/browser-dom-support.png" alt="browser dom support">
                    </a>

                </section>
                <section>
                    <h3>BOM</h3>
                    <p>Primarily, the BOM deals with the browser window and frames, but generally any browser - specific extension to JavaScript is considered to be a part of the BOM. The following are some such extensions:</p>
                    <ul>
                        <li>The capability to pop up new browser windows</li>
                        <li>The capability to move, resize, and close browser windows</li>
                        <li>The navigator object, which provides detailed information about the browser</li>
                        <li>The location object, which gives detailed information about the page loaded in the browser</li>
                        <li>The screen object, which gives detailed information about the user’s screen resolution</li>
                        <li>Support for cookies</li>
                        <li>Custom objects such as XMLHttpRequest and Internet Explorer’s ActiveXObject</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Core Concept</h2>
                </section>
                <section>
                    <h3>Primitive and Reference Values</h3>
                    <ul>
                        <li>Primitive values (ndefined, Null, Boolean, Number, and String) are simple pieces of data that are stored in memory on the stack , which is to say that the value is completely stored in one memory location.</li>
                        <li>Reference values , on the other hand, are objects that are stored on the heap , meaning that the value stored in the variable is actually just a pointer to another memory location where the object is stored.</li>
                    </ul>
                    <img src="images/reference-value-type-memory.png" alt="value type and reference type memory">
                </section>
                <section>
                    <h3>Dynamic Properties</h3>
                    <p>When working with reference values, properties and methods may be added, changed, or deleted at any time.</p>
                    <pre><code>var person = new Object();
person.name = “Nicholas”;
alert(person.name); //”Nicholas”
</code></pre>
                    <p>Primitive values can’t have properties added to them even though attempting to do so won’t cause an error.
                    </p>
                    <pre><code>var name = “Nicholas”;
name.age = 27;
alert(name.age); //undefined
</code></pre>
                </section>
                <section>
                    <h3>Copying Values</h3>
                    <p>When a primitive value is assigned from one variable to another, the value stored on the stack is created and copied into the location for the new variable.</p>
                    <pre><code>var num1 = 5;
var num2 = num1;</code></pre>
                    <img src="images/stack-copy.png" alt="stack copy">
                </section>
                <section>
                    <p>When a reference value is assigned from one variable to another, the value stored on the stack is also copied into the location for the new variable. The difference is that this value is actually a pointer to an object stored on the heap. Once the operation is complete, two variables point to exactly the same object, so changes to one are reflected on the other</p>
                    <pre><code>var obj1 = new Object();
var obj2 = obj1;
obj1.name = “Nicholas”;
alert(obj2.name); //”Nicholas”</code></pre>
                    <img src="images/reference-copy.png" alt="reference copy">
                </section>
                <section>
                    <h3>Argument Passing</h3>
                    <p>All function arguments in ECMAScript are passed by value. This means that the value outside of the function is copied into an argument on the inside of the function the same way a value is copied from one variable to another.</p>
                    <ul>
                        <li>If the value is primitive, then it acts just like a primitive variable copy</li>
                        <li>if the value is a reference, it acts just like a reference variable copy</li>
                    </ul>
                    <pre><code>function addTen(num) {
num += 10;
return num;
}
var count = 20;
var result = addTen(count);
alert(count); //20 - no change
alert(result); //30</code></pre>

                </section>
                <section>
                    <pre><code>function setName(obj) {
obj.name = “Nicholas”;
}
var person = new Object();
setName(person);
alert(person.name); //”Nicholas”</code></pre>
                    <pre><code>function setName(obj) {
obj.name = “Nicholas”;
obj = new Object();
obj.name = “Greg”;
}
var person = new Object();
setName(person);
alert(person.name); //”Nicholas”</code></pre>
                </section>
                <section>
                    <h3>Determining Type</h3>
                    <p>The typeof operator, introduced in the previous chapter, is the best way to determine if a variable is a primitive type.</p>
                    <pre><code>var s = “Nicholas”;
var b = true;
var i = 22;
var u;
var n = null;
var o = new Object();
alert(typeof s); //string
alert(typeof i); //number
alert(typeof b); //boolean
alert(typeof u); //undefined
alert(typeof n); //object
alert(typeof o); //object</code></pre>
                    <p>The instanceof operator returns true if the variable is an instance of the given reference type (identified by its constructor function).</p>
                    <pre><code>alert(person instanceof Object); //is the variable person an Object?
alert(colors instanceof Array); //is the variable colors an Array?
alert(pattern instanceof RegExp); //is the variable pattern a RegExp?</code></pre>
                </section>
                <section>
                    <h3>Execution Context</h3>
                    <p>The execution context of a variable or function defines what other data it has access to, as well as how it should behave. Each execution context has an associated variable object upon which all of its defined variables and functions exist. This object is not accessible by code but is used behind the scenes to handle data.</p>
                    <img src="images/execution-context-scope-chain.png" alt="execution context scope chain">
                </section>
                <section>
                    <h3>Scope</h3>
                    <p>When code is executed in a context, a scope chain of variable objects is created. The purpose of the scope chain is to provide ordered access to all variables and functions that an execution context has access to.</p>
                    <pre><code>var color = "blue";
function changeColor(){
    var anotherColor = "red";
    function swapColors(){
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        //color, anotherColor, and tempColor are all accessible here
    }
    //color and anotherColor are accessible here, but not tempColor
    swapColors();
}
//only color is accessible here
changeColor();</code></pre>
                    <img src="images/scope-chain.png" alt="scope chain">
                </section>
                <section>
                    <h3>Scope Chain Augmentation</h3>
                    <p>Even though there are only two types of execution contexts, global and local (function), there are other ways to augment the scope chain.</p>
                    <ul>
                        <li>The catch block in a try - catch statement</li>
                        <li>A with statement</li>
                    </ul>
                    <pre><code>function buildUrl() {
var qs = "?debug=true";
with(location){
    var url = href + qs;
}
return url;
}</code></pre>
                </section>

                <section>
                    <h3>No Block-Level Scopes</h3>
                    <p>JavaScript ’ s lack of block - level scopes is a common source of confusion.</p>
                    <pre><code>for (var i=0; i < 10; i++){
    doSomething(i);
}
alert(i); //10
                    </code></pre>
                </section>
                <section>
                    <h3>Variable Declaration</h3>
                    <ul>
                        <li>When a variable is declared using var, it is automatically added to the most immediate context available.</li>
                        <li>If a variable is initialized without first being declared, it gets added to the global context automatically</li>
                    </ul>
                    <pre><code>function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}
var result = add(10, 20); //30
alert(sum); //30</code></pre>
                    <p style="color:orange">Initializing variables without declaring them is a very common mistake in JavaScript programming and can lead to errors. It’s advisable to always declare variables before initializing them to avoid such issues.</p>
                </section>
                <section>
                    <h3>Identifier Lookup</h3>
                    <pre><code>var color = "blue";
function getColor(){
return color;
}
alert(getColor()); //"blue"</code></pre>
                    <img src="images/identifier-lookup.png" alt="identifier lookup">
                    <p style="color:orange">Variable lookup doesn ’ t come without a price. It ’ s faster to access local variables than global variables because there ’ s no search up the scope chain.</p>
                </section>
                <section>
                    <h3>Event Flow</h3>
                    <p>Event flow describes the order in which events are received on the page, the IE and Netscape development teams came up with an almost exactly opposite concept of event flow.</p>
                    <ul>
                        <li> IE would support an event bubbling flow</li>
                        <li>Netscape Communicator would support an event capturing flow</li>
                    </ul>
                </section>
                <section>
                    <h3>Event Bubbling</h3>
                    <p>The IE event flow is called event bubbling , because an event is said to start at the most specific element (the deepest possible point in the document tree) and then flow upward towards the least specific node (the document).</p>
                    <pre><code>&lt; html &gt;
&lt; head &gt;
&lt; title &gt; Event Bubbling Example &lt; /title &gt;
&lt; /head &gt;
&lt; body &gt;
&lt; div id=”myDiv” &gt; Click Me &lt; /div &gt;
&lt; /body &gt;
&lt; /html &gt;</code></pre>
                </section>

                <section>
                    <h3>Event Capturing</h3>
                    <p>The Netscape Communicator team came up with an alternate event flow called event capturing . The theory of event capturing is that the least specific node should receive the event first and the most specific node should receive the event last.</p>
                    <img src="images/event-capturing.png" alt="event capturing">
                </section>
                <section>
                    <h3>DOM Event Flow</h3>
                    <p>The event flow specified by DOM Level 2 Events has three phases: the event capturing phase, at the target, and the event bubbling phase.</p>
                    <img src="images\dom-events.png" alt="dom events">
                </section>
                <section>
                    <h3>Cross-Browser Event Handler</h3>
                    <pre><code>var EventUtil = {
    addHandler: function(element, type, handler){
        if (element.addEventListener){
        element.addEventListener(type, handler, false);
        } else if (element.attachEvent){
        element.attachEvent("on" + type, handler);
        } else {
        element["on" + type] = handler;
        }
    },
    removeHandler: function(element, type, handler){
        if (element.removeEventListener){
        element.removeEventListener(type, handler, false);
        } else if (element.detachEvent){
        element.detachEvent("on" + type, handler);
        } else {
        element["on" + type] = null;
        }
    }
};

var btn = document.getElementById(“myBtn”);
var handler = function(){
alert(“Clicked”);
};
EventUtil.addHandler(btn, “click”, handler);
//other code here
EventUtil.removeHandler(btn, “click”, handler);</code></pre>
                    <img src="images/add-event-listener-browser-support.png" alt="add event listener brower support">
                </section>
                <section>
                    <h3>Prototypes</h3>
                    <ul>
                        <li>Objects in JavaScript are based on prototypes. A prototype is an object that serves as the base of another object, defining and implementing members that a new object must have.</li>
                        <li>Prototype objects are shared amongst all instances of a given object type, and so all instances also share the prototype object’s members. </li>
                        <li>Consequently, objects can have two types of members: instance members (also called “own” members) and prototype members. Instance members exist directly on the object instance itself, whereas prototype members are inherited from the object prototype. </li>
                    </ul>
                </section>
                <section>
                    <pre><code>var book = {    
                title: "High Performance JavaScript",    
                publisher: "Yahoo! Press" 
                };
alert(book.toString());   //"[object Object]"
</code></pre>
                    <img src="images/prototypes.png" alt="javascript prototypes">
                </section>
                <section>
                    <h3>Prototype Chains</h3>
                    <p>The prototype of an object determines the type or types of which it is an instance. By default, all objects are instances of Object and inherit all of the basic methods, such as toString().</p>
                    <pre><code>function Book(title, publisher){    
                    this.title = title;    
                    this.publisher = publisher; }
Book.prototype.sayTitle = function(){    
alert(this.title); 
};
var book1 = new Book("High Performance JavaScript", "Yahoo! Press"); 
var book2 = new Book("JavaScript: The Good Parts", "Yahoo! Press");
alert(book1 instanceof Book);   //true alert(book1 instanceof Object); //true
book1.sayTitle();         //"High Performance JavaScript" 
alert(book1.toString());  //"[object Object]" 
                    </code></pre>
                    <img src="images/prototype-chain.png" alt="prototype chain">
                </section>
            </section>

            <section>
                <h2>THE END</h2>
                <p>BY <a href="http://browserwork.com/contact.html" target="_blank">Aaron Zhang</a> / <a href="http://browserwork.com">browserwork.com</a>
                </p>
            </section>

        </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [{
            src: 'lib/js/classList.js',
            condition: function() {
                return !document.body.classList;
            }
        }, {
            src: 'plugin/markdown/marked.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/markdown/markdown.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() {
                hljs.initHighlightingOnLoad();
            }
        }, {
            src: 'plugin/zoom-js/zoom.js',
            async: true,
            condition: function() {
                return !!document.body.classList;
            }
        }, {
            src: 'plugin/notes/notes.js',
            async: true,
            condition: function() {
                return !!document.body.classList;
            }
        }]
    });
    </script>

</body>

</html>
