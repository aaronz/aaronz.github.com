---
layout: slide 
title: Images, Audio and Video
description: Only use media that loads fast and scales
---

<link rel="stylesheet" href="css/slide.css">
<section id="agenda">
    <h3>agenda</h3>
                <ul>
                    <li><a href="#images">Images</a>
                    </li>
                    <li><a href="#video">Video</a>
                    </li>
                </ul>
            </section>
            <section>
                <section id="images">
                    <h2>Images</h2>
                </section>
            </section>
            <section>
                <section>
                    <h2>Images in Markup</h2>
                </section>
                <section>
                    <p>The <code>img</code> element is powerful – it downloads, decodes and renders content – and modern browsers support a range of image formats. Including images that work across devices is no different than for desktop, and only requires a few minor tweaks to create a good experience.</p>
                    <ul>
                        <li>Use relative sizes for images to prevent them from accidentally overflowing the container.</li>
                        <li>Use the <code>picture</code> element when you want to specify different images depending on device characteristics (a.k.a. art direction).</li>
                        <li>Use <code>srcset</code> and the <code>x</code> descriptor in the <code>img</code> element to give hints to the browser about the best image to use when choosing from different densities.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="use-relative-sizes-for-images">Use relative sizes for images</h2>
                    <p>Remember to use relative units when specifying widths for images to prevent them from accidentally overflowing the viewport. For example, <code>width: 50%;</code>, will cause the image width to be 50% of the containing element (not the viewport or actual pixel size).</p>
                    <p>Because CSS allows content to overflow its container, it may be necessary use max-width: 100% to prevent images and other content from overflowing. For example:</p><pre><code>img, embed, object, video {
  max-width: 100%;
}</code></pre>
                </section>
                <section>
                    <p>Be sure to provide meaningful descriptions via the <code>alt</code> attribute on <code>img</code> elements; these help make your site more accessible by providing context to screen readers and other assistive technologies.</p>
                </section>
                <section>
                    <h2 id="enhance-imgs-with-srcset-for-high-dpi-devices">Enhance <code>img</code>’s with <code>srcset</code> for high DPI devices</h2>
                    <p>The <code>srcset</code> attribute enhances the behavior of the <code>img</code> element, making it easy to provide multiple image files for different device characteristics. Similar to the <code>image-set</code> <a href="images-in-css.html#use-image-set-to-provide-high-res-images">CSS function</a> native to CSS, <code>srcset</code> allows the browser to choose the best image depending on the characteristics of the device, for example using a 2x image on a 2x display, and potentially in the future, a 1x image on a 2x device when on a limited bandwidth network.</p><pre><code>&lt;img src="photo.png" srcset="photo@2x.png 2x" ...&gt;</code></pre>
                </section>
                <section>
                    <p>On browsers that don’t support <code>srcset</code>, the browser simply uses the default image file specified by the <code>src</code> attribute. This is why it is important to always include a 1x image that can be displayed on any device, regardless of capabilities. When <code>srcset</code> is supported, the comma-separated list of image/conditions is parsed prior to making any requests, and only the most appropriate image is downloaded and displayed.</p>
                    <p>While the conditions can include everything from pixel density to width and height, only pixel density is well supported today. To balance current behavior with future features, stick with simply providing the 2x image in the attribute.</p>
                </section>
                <section>
                    <h2 id="art-direction-in-responsive-images-with-picture">Art direction in responsive images with <code>picture</code></h2>
                    <p>Changing images based on device characteristics, also known as art direction can be accomplished using the picture element. The <code>picture</code> element defines a declarative solution for providing multiple versions of an image based on different characteristics, like device size, device resolution, orientation, and more.</p>
                    <<<<<<< HEAD <p><img alt="Art direction example" src="images/art-direction.png" srcset="images/art-direction.png 1x, images/art-direction-2x.png 2x" /> =======
                        <p><img alt="Art direction example" src="images/art-direction.png" srcset="images/art-direction.png 1x, images/art-direction-2x.png 2x" /> >>>>>>> origin/master
                        </p>
                </section>
                <section>
                    <p>Important</p>
                    <ul>
                        <li>The <code>picture</code> element is beginning to land in browsers. Although it's not available in every browser yet, we recommend its use because of the strong backward compatibility and potential use of the <a href="http://picturefill.responsiveimages.org/">Picturefill polyfill</a>. See the <a href="http://responsiveimages.org/#implementation">ResponsiveImages.org</a> site for further details.</li>
                    </ul>
                </section>
                <section>
                    <p>The <code>picture</code> element should be used when an image source exists in multiple densities, or when a responsive design dictates a somewhat different image on some types of screens. Similar to the <code>video</code> element, multiple <code>source</code> elements can be included, making it possible to specify different image files depending on media queries or image format.</p><pre><code>    &lt;picture&gt;
      &lt;source media="(min-width: 800px)" srcset="head.jpg, head-2x.jpg 2x"&gt;
      &lt;source media="(min-width: 450px)" srcset="head-small.jpg, head-small-2x.jpg 2x"&gt;
      &lt;img src="head-fb.jpg" srcset="head-fb-2x.jpg 2x" &gt;
    &lt;/picture&gt;</code></pre>
                </section>
                <section>
                    <p>In the above example, if the browser width is at least 800px, then either <code>head.jpg</code> or <code>head-2x.jpg</code> will be used, depending on the device resolution. If the browser is between 450px and 800px, then either <code>head-small.jpg</code> or <code>head-small-2x.jpg</code> will be used, again, depending on the device resolution. For screen widths less than 450px and backwards compatibility where the <code>picture</code> element isn’t supported, the browser will render the <code>img</code> element instead, and should always be included.</p>
                    <p>When the final size of the image isn’t known, it can be difficult to specify a density descriptor for the image sources. This is especially true for images that span a proportional width of the browser and are fluid, depending on the size of the browser.</p>
                    <p>Instead of supplying fixed image sizes and densities, the size of each supplied image can be specified by adding a width descriptor along with the size of the image element, allowing the browser to automatically calculate the effective pixel density and choose the best image to download.</p><pre><code>    &lt;img src="lighthouse-200.jpg" sizes="50vw"
         srcset="lighthouse-100.jpg 100w, lighthouse-200.jpg 200w,
                 lighthouse-400.jpg 400w, lighthouse-800.jpg 800w,
                 lighthouse-1000.jpg 1000w, lighthouse-1400.jpg 1400w,
                 lighthouse-1800.jpg 1800w"&gt;</code></pre>
                </section>
                <section>
                    <p>The above example renders an image that is half of the viewport width (<code>sizes="50vw"</code>), and depending on the width of the browser and it’s device pixel ratio, allowing the browser to choose the correct image regardless of how large the browser window is. For example, the table below shows which image the browser would choose:</p>
                    <p>In many cases, the size or image may change depending on the site’s layout breakpoints. For example, on a small screen, you might want the image to span the full width of the viewport, while on larger screens, it should only take a small proportion.</p><pre><code>    &lt;img src="400.png"
         sizes="(min-width: 600px) 25vw, (min-width: 500px) 50vw, 100vw"
         srcset="100.png 100w, 200.png 200w, 400.png 400w,
                 800.png 800w, 1600.png 1600w, 2000.png 2000w"&gt;</code></pre>
                </section>
                <section>
                    <p>The <code>sizes</code> attribute in the above example uses several media queries to specify the size of the image. When the browser width is greater than 600px, the image will be 25% of the viewport width, when it is between 500px and 600px, the image will be 50% of the viewport width, and below 500px, it will be full width.</p>
                </section>
                <section>
                    <h2 id="make-product-images-expandable">Make product images expandable</h2>
                    <p>Customers want to see what they’re buying. On retail sites, users expect to be able to view high resolution closeups of products to get a better look at details, and <a href="https://developers.google.com/web/fundamentals/principles/research-study.html">study participants</a> got frustrated if they weren’t able to.</p>
                    <p>A good example of tappable, expandable images is provided by the J. Crew site.
                        <br>An disappearing overlay indicates that an image is tappable, providing a zoomed in image with fine detail visible.</br>
                    </p>
                </section>
                <section>
                    <h2 id="other-image-techniques">Other image techniques</h2>
                    <p>The <a href="http://www.html5rocks.com/en/mobile/high-dpi/#toc-tech-overview">compressive image technique</a> serves a highly compressed 2x image to all devices, no matter the actual capabilities of the device. Depending on the type of image and level of compression, image quality may not appear to change, but the file size drops significantly.</p>
                    <p><a href="http://googlesamples.github.io/web-fundamentals/samples/media/images/compressive.html">See example</a>
                    </p>
                </section>
                <section>
                    <p>Important</p>
                    <ul>
                        <li>Use caution with the compressive technique because of the increased memory and decoding costs it requires. Resizing large images to fit on smaller screens is expensive and can be particularly painful on low-end devices where both memory and processing is limited.</li>
                    </ul>
                </section>
                <section>
                    <p>JavaScript image replacement checks the capabilities of the device and "does the right thing". You can determine device pixel ratio via <code>window.devicePixelRatio</code>, get screen width and height, and even potentially do some network connection sniffing via <code>navigator.connection</code> or issuing a fake request. Once you’ve collected all of this information, you can decide which image to load.</p>
                    <p>One big drawback to this approach is that using JavaScript means that you will delay image loading until at least the look-ahead parser has finished. This means that images won’t even start downloading until after the <code>pageload</code> event fires. In addition, the browser will most likely download both the 1x and 2x images, resulting in increased page weight.</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Images in CSS</h2>
                </section>
                <section>
                    <p>The CSS `background` property is a powerful tool for adding complex images to elements, making it easy to add multiple images, cause them to repeat, and more. When combined with media queries, the background property becomes even more powerful, enabling conditional image loading based on screen resolution, viewport size and more.</p>
                    <ul>
                        <li>Use the best image for the characteristics of the display, consider screen size, device resolution and page layout.</li>
                        <li>Change the <code>background-image</code> property in CSS for high DPI displays using media queries with <code>min-resolution</code> and <code>-webkit-min-device-pixel-ratio</code>.</li>
                        <li>Use srcset to provide high resolution images in addition to the 1x image in markup.</li>
                        <li>Consider the performance costs when using JavaScript image replacement techniques or when serving highly compressed high resolution images to lower resolution devices.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="use-media-queries-for-conditional-image-loading-or-art-direction">Use media queries for conditional image loading or art direction</h2>
                    <p>Media queries not only affect the page layout, but can also be used to conditionally load images or to provide art direction depending on the viewport width.</p>
                    <p>For example in the sample below, on smaller screens, only <code>small.png</code> is downloaded and applied to the content <code>div</code>, while on larger screens, <code>background-image: url(body.png)</code> is applied to the body and <code>background-image: url(large.png)</code> is applied to the content <code>div</code>.</p><pre><code>    .example {
      height: 400px;
      background-image: url(small.png);
      background-repeat: no-repeat;
      background-size: contain;
      background-position-x: center;
    }
    @media (min-width: 500px) {
      body {
        background-image: url(body.png);
      }
      .example {
        background-image: url(large.png);
      }
    }</code></pre>
                </section>
                <section>
                    <h2 id="use-image-set-to-provide-high-res-images">Use image-set to provide high res images</h2>
                    <p>The <code>image-set()</code> function in CSS enhances the behavior <code>background</code> property, making it easy to provide multiple image files for different device characteristics. This allows the browser to choose the best image depending on the characteristics of the device, for example using a 2x image on a 2x display, or a 1x image on a 2x device when on a limited bandwidth network.</p><pre><code>background-image: image-set(
  url(icon1x.jpg) 1x,
  url(icon2x.jpg) 2x
);</code></pre>
                </section>
                <section>
                    <p>In addition to loading the correct image, the browser will also scale it accordingly. In other words, the browser assumes that 2x images are twice as large as 1x images, and so will scale the 2x image down by a factor of 2, so that the image appears to be the same size on the page.</p>
                    <p>Support for <code>image-set()</code> is still new and is only supported in Chrome and Safari with the <code>-webkit</code> vendor prefix. Care must also be taken to include a fallback image for when <code>image-set()</code> is not supported, for example:</p><pre><code>    .sample {
      width: 128px;
      height: 128px;
      background-image: url(icon1x.png);
      background-image: -webkit-image-set(
        url(icon1x.png) 1x,
        url(icon2x.png) 2x
      );
      background-image: image-set(
        url(icon1x.png) 1x,
        url(icon2x.png) 2x
      );
    }</code></pre>
                </section>
                <section>
                    <p>The above will load the appropriate asset in browsers that support image-set, and fall back to the 1x asset otherwise. The obvious caveat is that while <code>image-set()</code> browser support is low, most browsers will get the 1x asset.</p>
                </section>
                <section>
                    <h2 id="use-media-queries-to-provide-high-res-images-or-art-direction">Use media queries to provide high res images or art direction</h2>
                    <p>Media queries can create rules based on the <a href="http://www.html5rocks.com/en/mobile/high-dpi/#toc-bg">device pixel ratio</a>, making it possible to specify different images for 2x vs 1x displays.</p><pre><code>@media (min-resolution: 2dppx),
(-webkit-min-device-pixel-ratio: 2)
{
  /* High dpi styles &amp; resources here */
}</code></pre>
                </section>
                <section>
                    <p>Chrome, Firefox and Opera all support the standard <code>(min-resolution: 2dppx)</code>, while Safari and Android Browser both require the older vendor prefixed syntax without the <code>dppx</code> unit. Remember, these styles are only loaded if the device matches the media query, and you must specify styles for the base case. This also provides the benefit of ensuring something will be rendered if the browser doesn’t support resolution specific media queries.</p><pre><code>    .sample {
      width: 128px;
      height: 128px;
      background-image: url(icon1x.png);
    }
    @media (min-resolution: 2dppx), /* Standard syntax */
    (-webkit-min-device-pixel-ratio: 2)  /* Safari &amp; Android Browser */
    {
      .sample {
        background-size: contain;
        background-image: url(icon2x.png);
      }
    }</code></pre>
                </section>
                <section>
                    <p>You can also use the min-width syntax to display alternative images depending on the viewport size. This technique has the advantage that the image is not downloaded if media query doesn’t match. For example, <code>bg.png</code> is only downloaded and applied to the <code>body</code> if the browser width is 500px or greater:</p><pre><code>@media (min-width: 500px) {
  body {
    background-image: url(bg.png);
  }
}</code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Use SVG for icons</h2>
                </section>
                <section>
                    <p>When adding icons to your page, use SVG icons where possible or in some cases, unicode characters.</p>
                    <ul>
                        <li>Use SVG or unicode for icons instead of raster images.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="replace-simple-icons-with-unicode">Replace simple icons with unicode</h2>
                    <p>Many fonts include support for the myriad of unicode glyphs, which can be used instead of images. Unlike images, unicode fonts scale well, and look good no matter how small or large they appear on screen.</p>
                    <p>Including a unicode character is done in the same way named entities are: <code>&amp;#XXXX</code>, where <code>XXXX</code> represents the unicode character number. For example:</p><pre><code>You're a super &amp;#9733;</code></pre>
                </section>
                <section>
                    <h2 id="replace-complex-icons-with-svg">Replace complex icons with SVG</h2>
                </section>
                <section>
                    <p>For more complex icon requirements, SVG icons are generally lightweight, easy to use and can be styled with CSS. SVG have a number of advantages over raster images:</p>
                    <ul>
                        <li>They’re vector graphics that can be infinitely scaled.</li>
                        <li>CSS effects such as color, shadowing, transparency and animations are straightforward.</li>
                        <li>SVG images can be inlined right in the document.</li>
                        <li>They are semantic.</li>
                        <li>Provide better accessibility with the appropriate attributes.</li>
                    </ul>
                </section>
                <section>
                    <p> </p><pre><code>    With SVG icons, you can either add icons using inline SVG, like
    this checkmark:
      &lt;svg version="1.1" xmlns="http://www.w3.org/2000/svg"
           xmlns:xlink="http://www.w3.org/1999/xlink"
           width="32" height="32" viewBox="0 0 32 32"&gt;
        &lt;path d="M27 4l-15 15-7-7-5 5 12 12 20-20z" fill="#000000"&gt;&lt;/path&gt;
      &lt;/svg&gt;
    or by using an image tag, like this credit card icon:
    &lt;img src="credit.svg"&gt;.</code></pre>
                </section>
                <section>
                    <h2 id="use-icon-fonts-with-caution">Use icon fonts with caution</h2>
                </section>
                <section>
                    <p>Icon fonts are popular, and can be easy to use, but have some drawbacks compared to SVG icons.</p>
                    <ul>
                        <li>They’re vector graphics that can be infinitely scaled, but may be anti-aliased resulting in icons that aren’t as sharp as expected.</li>
                        <li>Limited styling with CSS.</li>
                        <li>Pixel perfect positioning can be difficult, depending on line-height, letter spacing, etc.</li>
                        <li>Are not semantic, and can be difficult to use with screen readers or other assistive technology.</li>
                        <li>Unless properly scoped, can result in a large file size for only using a small subset of the icons available.</li>
                    </ul>
                </section>
                <section>
                    <p>
                        <a href="http://googlesamples.github.io/web-fundamentals/samples/media/images/icon-font.html"><img alt="Example of a page that uses FontAwesome for its font icons." src="images/icon-fonts.png" srcset="images/icon-fonts.png 1x, images/icon-fonts-2x.png 2x" />
                        </a>
                    </p><pre><code>    With Font Awesome, you can either add icons by using a unicode
    entity, like this HTML5 logo (&lt;span&gt;&amp;#xf13b;&lt;/span&gt;)
    or by adding special classes to an &amp;lt;i&amp;gt; element like the CSS3
    logo (&lt;i&gt;&lt;/i&gt;).</code></pre>
                </section>
                <section>
                    <p>There are hundreds of free and paid icon fonts available including <a href="http://fortawesome.github.io/Font-Awesome/">Font Awesome</a>, <a href="http://pictos.cc/">Pictos</a> and <a href="http://glyphicons.com/">Glyphicons</a>.</p>
                    <p>Be sure to balance the weight of the additional HTTP request and file size with the need for the icons. For example, if you only need a handful of icons, it may be better to use an image or an image sprite.</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Optimize images for performance</h2>
                </section>
                <section>
                    <p>Images often account for most of the downloaded bytes and also often occupy a significant amount of the visual space on the page. As a result, optimizing images can often yield some of the largest byte savings and performance improvements for your website: the fewer bytes the browser has to download, the less competition there is for client's bandwidth and the faster the browser can download and display all the assets.</p>
                    <ul>
                        <li>Don't just randomly choose an image format, understand the different formats available, and use the format best suited.</li>
                        <li>Include image optimization and compression tools into your workflow to reduce file sizes.</li>
                        <li>Reduce the number of http requests by placing frequently used images into image sprites.</li>
                        <li>Consider loading images only after they’ve scrolled into view to improve the initial page load time and reduce the initial page weight.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="choose-the-right-format">Choose the right format</h2>
                    <p>There are two types of images to consider: <a href="http://en.wikipedia.org/wiki/Vector_graphics">vector images</a> and <a href="http://en.wikipedia.org/wiki/Raster_graphics">raster images</a>. For raster images, you also need to choose the right compression format, for example: <code>GIF</code>, <code>PNG</code>, <code>JPG</code>.</p>
                    <p><strong>Raster images</strong>, like photographs and other images which are represented as a grid of individual dots or pixels. Raster images typically come from a camera or scanner, or can be created in the browser with the <code>canvas</code> element. As the image size gets larger, the file size grows as well. When scaled larger than their original size, raster images get blurry as the browser needs to guess how to fill in the missing pixels.</p>
                    <p><strong>Vector images</strong>, such as logos and line art are be defined by a set of curves, lines, shapes and fill colors. Vector images are created with programs like Adobe Illustrator or Inkscape and saved to a vector format like <a href="http://css-tricks.com/using-svg/"><code>SVG</code></a>. Because vector images are built on simple primitives, they can be scaled without any loss in quality without a change in file size.</p>
                    <p>When choosing the right format, it is important to consider both the origin of the image (raster or vector), and the content (colors, animation, text, etc). No one format will fit all image types and each has its own strengths and weaknesses.</p>
                </section>
                <section>
                    <p>Start with these guidelines when choosing the right format:</p>
                    <ul>
                        <li>Use <code>JPG</code> for photographic images.</li>
                        <li>Use <code>SVG</code> for vector art and solid color graphics such as logos and line art. If vector art is unavailable, try WebP or PNG.</li>
                        <li>Use <code>PNG</code> rather than <code>GIF</code> as it allows for more colors and offers better compression ratios.</li>
                        <li>For longer animations, consider using <code>&lt;video&gt;</code> which provide better image quality and gives the user control over playback.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="reduce-the-file-size">Reduce the file size</h2>
                    <p>Image file size can be considerably reduced by ‘post-processing’ them after saving. There are a number of tools for image compression – lossy and lossless, online, GUI, command line. Where possible, it’s best to try automating image optimization so that it’s a first-class citizen in your workflow.</p>
                    <p>Several tools are available that perform further, lossless compression on <code>JPG</code> and <code>PNG</code> files, with no effect on image quality. For <code>JPG</code>, try <a href="http://jpegclub.org/">jpegtran</a> or <a href="http://freshmeat.net/projects/jpegoptim/">jpegoptim</a> (available on Linux only; run with the –strip-all option). For <code>PNG</code>, try <a href="http://optipng.sourceforge.net/">OptiPNG</a> or <a href="http://www.advsys.net/ken/util/pngout.htm">PNGOUT</a>.</p>
                </section>
                <section>
                    <h2 id="use-image-sprites">Use image sprites</h2>
                    <p>CSS spriting is a technique whereby a number of images are combined in a single ‘sprite sheet’ image. Individual images can then be used by specifying the background image for an element (the sprite sheet) plus an offset to display the correct part.</p>
                    <p>
                        <<<<<<< HEAD <a href="http://googlesamples.github.io/web-fundamentals/samples/media/images/image-sprite.html"><img alt="Image sprite sheet used in example" src="images/sprite-sheet.png" /> =======
                            <a href="http://googlesamples.github.io/web-fundamentals/samples/media/images/image-sprite.html"><img alt="Image sprite sheet used in example" src="images/sprite-sheet.png" /> >>>>>>> origin/master
                            </a>
                    </p><pre><code>    .sprite-sheet {
      background-image: url(sprite-sheet.png);
      width: 40px;
      height: 25px;
    }
    .google-logo {
      width: 125px;
      height: 45px;
      background-position: -190px -170px;
    }
    .gmail {
      background-position: -150px -210px;
    }
    .maps {
      height: 40px;
      background-position: -120px -165px;
    }</code></pre>
                </section>
                <section>
                    <p>Spriting has the advantage of reducing the number of downloads required to get multiple images, while still enabling caching.</p>
                </section>
                <section>
                    <h2 id="consider-lazy-loading">Consider lazy loading</h2>
                    <p>Lazy loading can significantly speed up loading on long pages that include many images below the fold by loading them either as needed or once the primary content has finished loading and rendering. In addition to performance improvements, using lazy loading can create infinite scrolling experiences.</p>
                </section>
                <section>
                    <p>Be careful when creating infinite scrolling pages, because content is loaded as it becomes visible, search engines may never see that content. In addition, users who are looking for information they expect to see in the footer will never see the footer because new content is always loaded.</p>
                    <ul>
                        <li>
                            <p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/" title="Optimizing Content Efficiency">Optimizing Content Efficiency</a>
                            </p>
                            <p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer.html#image-optimization">Image optimization</a>
                            </p>
                        </li>
                    </ul>
                </section>
                <section>
                    <p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/" title="Optimizing Content Efficiency">Optimizing Content Efficiency</a>
                    </p>
                    <p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer.html#image-optimization">Image optimization</a>
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Avoid images completely</h2>
                </section>
                <section>
                    <p>Sometimes, the best image isn't actually an image at all. Whenever possible, use the native capabilities of the browser to provide the same or similar functionality. Browsers generate visuals that would have previously required images. This means that browsers no longer need to download separate image files and prevents awkwardly scaled images. Icons can be rendered using unicode or special icon fonts.</p>
                    <ul>
                        <li>Avoid images whenever possible, instead, leverage browser capabilities for shadows, gradients, rounded corners and more.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="place-text-in-markup-instead-of-embedded-in-images">Place text in markup, instead of embedded in images</h2>
                    <p>Wherever possible, text should be text, and not embedded into images, for example using images for headlines, or placing contact information like phone numbers or addresses directly into images. This prevents people from being able to copy and paste the information, makes it inaccessible for screen readers, and isn’t responsive. Instead, place the text in your markup and if necessary use webfonts to achieve the style you need.</p>
                </section>
                <section>
                    <h2 id="use-css-to-replace-images">Use CSS to replace images</h2>
                    <p>Modern browsers can use CSS features to create styles that would previously required images. For examples, complex gradients can be created using the <code>background</code> property, shadows can be created using <code>box-shadow</code> and rounded corners can be added with the <code>border-radius</code> property.</p>
                    <p id="noImage">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque sit amet augue eu magna scelerisque porta ut ut dolor. Nullam placerat egestas nisl sed sollicitudin. Fusce placerat, ipsum ac vestibulum porta, purus dolor mollis nunc, pharetra vehicula nulla nunc quis elit. Duis ornare fringilla dui non vehicula. In hac habitasse platea dictumst. Donec ipsum lectus, hendrerit malesuada sapien eget, venenatis tempus purus.</p><pre><code>&lt;style&gt;
  div#noImage {
    color: white;
    border-radius: 5px;
    box-shadow: 5px 5px 4px 0 rgba(9,130,154,0.2);
    background: linear-gradient(rgba(9, 130, 154, 1), rgba(9, 130, 154, 0.5));
  }
&lt;/style&gt;</code></pre>
                </section>
                <section>
                    <p>Keep in mind that using these techniques does require rendering cycles, which can be significant on mobile. If over-used, you’ll lose any benefit you may have gained and may hinder performance.</p>
                </section>
            </section>
            <section>
                <section id="video">
                    <h2>Video</h2>
                </section>
            </section>
            <section>
                <section>
                    <h2>Add a video</h2>
                </section>
                <section>
                    <p>Learn about the simplest ways to add video to your site and ensure users get the best possible experience on any device.</p>
                    <ul>
                        <li>Use the video element to load, decode, and play video on your site.</li>
                        <li>Produce video in multiple formats to cover a range of mobile platforms.</li>
                        <li>Size videos correctly; ensure they don't overflow their containers.</li>
                        <li>Accessibility matters; add the track element as a child of the video element.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="add-the-video-element">Add the video element</h2>
                    <p>Add the video element to load, decode, and play video in your site:</p>
                    <p>This browser does not support the video element.</p><pre><code>&lt;video src="chrome.webm" type="video/webm"&gt;
    &lt;p&gt;Your browser does not support the video element.&lt;/p&gt;
&lt;/video&gt;</code></pre>
                </section>
                <section>
                    <h2 id="specify-multiple-file-formats">Specify multiple file formats</h2>
                    <p>Not all browsers support the same video formats. The <code>&lt;source&gt;</code> element lets you specify multiple formats as a fallback in case the user’s browser doesn’t support one of them. For example:</p><pre><code>    &lt;video controls&gt;
      &lt;source src="chrome.webm" type="video/webm"&gt;
      &lt;source src="chrome.mp4" type="video/mp4"&gt;
      &lt;p&gt;This browser does not support the video element.&lt;/p&gt;
    &lt;/video&gt;</code></pre>
                </section>
                <section>
                    <p>When the browser parses the <code>&lt;source&gt;</code> tags, it uses the optional <code>type</code> attribute to help decide which file to download and play. If the browser supports WebM, it will play chrome.webm, if not, it will check if it can play MPEG-4 videos. Check out <a href="https://www.xiph.org/video/vid1.shtml" title="Highly entertaining and informative video guide to digital video">A Digital Media Primer for Geeks</a> to find out more about how video and audio work on the web.</p>
                </section>
                <section>
                    <p>This approach has several advantages over serving different HTML or server-side scripting, especially on mobile:</p>
                    <ul>
                        <li>Developers can list formats in order of preference.</li>
                        <li>Native client-side switching reduces latency; only one request is made to get content.</li>
                        <li>Letting the browser choose a format is simpler, quicker and potentially more reliable than using a server-side support database with user-agent detection.</li>
                        <li>Specifying each file source’s type improves network performance; the browser can select a video source without having to download part of the video to ‘sniff’ the format.</li>
                    </ul>
                </section>
                <section>
                    <p>All of these points are especially important in mobile contexts, where bandwidth and latency are at a premium, and the user’s patience is likely to be limited. Not including a type attribute can affect performance when there are multiple sources with unsupported types.</p>
                    <p>Using your mobile browser developer tools, compare network activity <a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/video-main.html">with type attributes</a> and <a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/notype.html">without type attributes</a>. Also check the response headers in your browser developer tools to <a href="https://developer.mozilla.org/en/docs/Properly_Configuring_Server_MIME_Types">ensure your server reports the right MIME type</a>; otherwise video source type checks won’t work.</p>
                </section>
                <section>
                    <h2 id="specify-a-start-and-end-time">Specify a start and end time</h2>
                    <p>Save bandwidth and make your site feel more responsive: use the Media Fragments API to add a start and end time to the video element.</p>
                    <p>This browser does not support the video element.</p>
                    <p>To add a media fragment, you simply add <code>#t=[start_time][,end_time]</code> to the media URL. For example, to play the video between seconds 5 through 10, specify:</p><pre><code>&lt;source src="video/chrome.webm#t=5,10" type="video/webm"&gt;</code></pre>
                </section>
                <section>
                    <p>You can also use the Media Fragments API to deliver multiple views on the same video – like cue points in a DVD – without having to encode and serve multiple files.</p>
                </section>
                <section>
                    <p>Remember</p>
                    <ul>
                        <li>The Media Fragments API is supported on most platforms, but not on iOS.</li>
                        <li>Make sure Range Requests are supported by your server. Range Requests are enabled by default on most servers, but some hosting services may turn them off.</li>
                    </ul>
                </section>
                <section>
                    <p>Using your browser developer tools, check for <code>Accept-Ranges: bytes</code> in the response headers:</p>
                    <p><img alt="Chrome Dev Tools screenshot: Accept-Ranges: bytes" src="images/Accept-Ranges-Chrome-Dev-Tools.png" />
                    </p>
                </section>
                <section>
                    <h2 id="include-a-poster-image">Include a poster image</h2>
                    <p>Add a poster attribute to the video element so that your users have an idea of the content as soon as the element loads, without needing to download video or start playback.</p><pre><code>&lt;video poster="poster.jpg" ...&gt;
  ...
&lt;/video&gt;</code></pre>
                </section>
                <section>
                    <p>A poster can also be a fallback if the video <code>src</code> is broken or none of the video formats supplied are supported. The only downside to poster images is an additional file request, which consumes some bandwidth and requires rendering. For more information see <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer.html#image-optimization">Image optimization</a>.</p>
                    <p>Here’s a side-by-side comparison of videos without and with a poster image – we’ve made the poster image grayscale to prove it’s not the video:</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Provide alternatives for legacy platforms</h2>
                    <p>Not all video formats are supported on all platforms. Check which formats are supported on the major platforms and make sure your video works in each of these.</p>
                </section>
                <section>
                    <h2 id="check-which-formats-are-supported">Check which formats are supported</h2>
                    <p>Use <code>canPlayType()</code> to find out which video formats are supported. The method takes a string argument consistent of a <code>mime-type</code> and optional codecs and returns one of the following values:</p>
                    <p>Here are some examples of <code>canPlayType()</code> arguments and return values when run in Chrome:</p>
                </section>
                <section>
                    <h2 id="produce-video-in-multiple-formats">Produce video in multiple formats</h2>
                </section>
                <section>
                    <p>There are lots of tools to help save the same video in different formats:</p>
                    <ul>
                        <li>Desktop tools: <a href="https://ffmpeg.org/">FFmpeg</a>
                        </li>
                        <li>GUI applications: <a href="https://www.mirovideoconverter.com/">Miro</a>, <a href="https://handbrake.fr/">HandBrake</a>, <a href="https://www.videolan.org/">VLC</a>
                        </li>
                        <li>Online encoding/transcoding services: <a href="https://en.wikipedia.org/wiki/Zencoder">Zencoder</a>, <a href="https://aws.amazon.com/elastictranscoder">Amazon Elastic Encoder</a>
                        </li>
                    </ul>
                </section>
                <section>
                    <h2 id="check-which-format-was-used">Check which format was used</h2>
                    <p>Want to know which video format was actually chosen by the browser?</p>
                    <p>In JavaScript, use the video’s <code>currentSrc</code> property to return the source used.</p>
                    <p>To see this in action, check out <a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/video-main.html">this demo</a>: Chrome and Firefox choose <code>chrome.webm</code> (because that’s the first in the list of potential sources these browsers support) whereas Safari chooses <code>chrome.mp4</code>.</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Size videos correctly</h2>
                </section>
                <section>
                    <p>When it comes to keeping your users happy, size matters.</p>
                    <ul>
                        <li>Don't serve videos with a larger frame size or higher quality than the platform can handle.</li>
                        <li>Don't make your videos any longer than they need be.</li>
                        <li>Long videos can cause hiccups with download and seeking; some browsers may have to wait until the video downloads before beginning playback.</li>
                    </ul>
                </section>
                <section>
                    <h2 id="check-video-size">Check video size</h2>
                    <p>The actual video frame size as encoded may be different from the video element dimensions (just as an image may not be displayed using its actual dimensions).</p>
                    <p>To check the encoded size of a video, use the video element <code>videoWidth</code> and <code>videoHeight</code> properties. <code>width</code> and <code>height</code> return the dimensions of the video element, which may have been sized using CSS or inline width and height attributes.</p>
                </section>
                <section>
                    <h2 id="ensure-videos-dont-overflow-containers">Ensure videos don’t overflow containers</h2>
                    <p>When video elements are too big for the viewport, they may overflow their container, making it impossible for the user to see the content or use the controls.</p>
                    <p>You can control video dimensions using JavaScript or CSS. JavaScript libraries and plugins such as <a href="https://fitvidsjs.com/">FitVids</a> make it possible to maintain appropriate size and aspect ratio, even for Flash videos from YouTube and other sources.</p>
                </section>
                <section>
                    <p>Use <a href="https://developers.google.com/web/fundamentals/layouts/rwd-fundamentals/#use-css-media-queries-for-responsiveness">CSS media queries</a> to specify the size of elements depending on the viewport dimensions; <code>max-width: 100%</code> is your friend.</p>
                    <ul>
                        <li>
                            <p><a href="https://developers.google.com/web/layouts/rwd-fundamentals/" title="Responsive Web Design Basics">Responsive Web Design Basics</a>
                            </p>
                            <p><a href="https://developers.google.com/web/fundamentals/layouts/rwd-fundamentals/use-media-queries.html">Use CSS media queries for responsiveness</a>
                            </p>
                        </li>
                    </ul>
                </section>
                <section>
                    <p><a href="https://developers.google.com/web/layouts/rwd-fundamentals/" title="Responsive Web Design Basics">Responsive Web Design Basics</a>
                    </p>
                    <p><a href="https://developers.google.com/web/fundamentals/layouts/rwd-fundamentals/use-media-queries.html">Use CSS media queries for responsiveness</a>
                    </p>
                    <p>For media content in iframes (such as YouTube videos), try a responsive approach (like the one <a href="https://avexdesigns.com/responsive-youtube-embed/">proposed by John Surdakowski</a>).</p>
                </section>
                <section>
                    <p>Remember</p>
                    <ul>
                        <li>Don't force element sizing that results in an aspect ratio different from the original video. Squashed or stretched looks bad.</li>
                    </ul>
                </section>
                <section>
                    <p><strong>CSS:</strong>
                    </p><pre><code>    .video-container {
        position: relative;
        padding-bottom: 56.25%;
        padding-top: 30px;
        height: 0;
        overflow: hidden;
    }
    .video-container iframe,
    .video-container object,
    .video-container embed {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }</code></pre>
                </section>
                <section>
                    <p><strong>HTML:</strong>
                    </p><pre><code>    &lt;div&gt;
      &lt;iframe src="//www.youtube.com/embed/l-BA9Ee2XuM"
              frameborder="0" width="560" height="315"&gt;
      &lt;/iframe&gt;
    &lt;/div&gt;</code></pre>
                </section>
                <section>
                    <p>Compare the <a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/responsive_embed.html">responsive sample</a> to the <a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/unyt.html">unresponsive version</a>.</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Customize the video player</h2>
                    <p>Different platforms display video differently. Mobile solutions need to consider device orientation. Use Fullscreen API to control the fullscreen view of video content.</p>
                    <p>Different platforms display video differently. Mobile solutions need to consider device orientation. Use Fullscreen API to control the fullscreen view of video content.</p>
                </section>
                <section>
                    <h2 id="how-device-orientation-works-across-devices">How device orientation works across devices</h2>
                    <p>Device orientation isn’t an issue for desktop monitors or laptops, but is hugely important when considering web page design for mobile and tablets.</p>
                    <p>Safari on iPhone does a good job of switching between portrait and landscape orientation:</p>
                    <p>Device orientation on an iPad and Chrome on Android can be problematic. For example, without any customization a video playing on an iPad in landscape orientation looks like this:</p>
                    <p><img alt="Screenshot of video playing in Safari on iPad Retina, landscape" src="images/iPad-Retina-landscape-video-playing.png" />
                    </p>
                </section>
                <section>
                    <p>Setting the video <code>width: 100%</code> or <code>max-width: 100%</code> with CSS can resolve many device orientation layout problems. You may also want to consider fullscreen alternatives.</p>
                </section>
                <section>
                    <h2 id="inline-or-fullscreen-display">Inline or fullscreen display</h2>
                    <p>Different platforms display video differently. Safari on an iPhone displays a video element inline on a web page, but plays video back in fullscreen mode:</p>
                    <p><img alt="Screenshot of video element on iPhone, portrait" src="images/iPhone-video-with-poster.png" />
                    </p>
                </section>
                <section>
                    <p>On Android, users can request request fullscreen mode by clicking the fullscreen icon. But the default is to play video inline:</p>
                    <p><img alt="Screenshot of video playing in Chrome on Android, portrait" src="images/Chrome-Android-video-playing-portrait-3x5.png" />
                    </p>
                </section>
                <section>
                    <p>Safari on an iPad plays video inline:</p>
                    <p><img alt="Screenshot of video playing in Safari on iPad Retina, landscape" src="images/iPad-Retina-landscape-video-playing.png" />
                    </p>
                </section>
                <section>
                    <h2 id="control-fullscreening-of-content">Control fullscreening of content</h2>
                    <p>For platforms that do not force fullscreen video playback, the Fullscreen API is <a href="https://caniuse.com/fullscreen">widely supported</a>. Use this API to control fullscreening of content, or the page.</p>
                    <p>To full screen an element, like a video:</p><pre><code>elem.requestFullScreen();</code></pre>
                </section>
                <section>
                    <p>To full screen the entire document:</p><pre><code>document.body.requestFullScreen();</code></pre>
                </section>
                <section>
                    <p>You can also listen for fullscreen state changes:</p><pre><code>video.addEventListener("fullscreenchange", handler);</code></pre>
                </section>
                <section>
                    <p>Or, check to see if the element is currently in fullscreen mode:</p><pre><code>console.log("In full screen mode: ", video.displayingFullscreen);</code></pre>
                </section>
                <section>
                    <p>You can also use the CSS <code>:fullscreen</code> pseudo-class to change the way elements are displayed in fullscreen mode.</p>
                    <p>On devices that support the Fullscreen API, consider using thumbnail images as placeholders for video:</p>
                    <p>This browser does not support the video element.</p>
                    <p>To see this in action, check out the <a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/fullscreen.html">demo</a>.</p>
                    <p><strong>NOTE:</strong> <code>requestFullScreen()</code> is currently vendor prefixed and may require extra code for full cross browser compatibility.</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Accessibility matters</h2>
                    <p>Accessibility isn't a feature. Users who can't hear or see won't be able to experience a video at all without captions or descriptions. The time it takes to add these to your video is much less than the bad experience you are delivering to users. Provide at least a base experience for all users.</p>
                </section>
                <section>
                    <h2 id="include-captions-to-improve-accessibility">Include captions to improve accessibility</h2>
                    <p>To make media more accessible on mobile, include captions or descriptions using the track element.</p>
                </section>
                <section>
                    <p>Remember</p>
                    <ul>
                        <li>The track element is supported on Chrome for Android, iOS Safari, and all current browsers on desktop except Firefox (see <a href="http://caniuse.com/track" title="Track element support status">caniuse.com/track</a>). There are several polyfills available too. We recommend <a href="https://www.delphiki.com/html5/playr/" title="Playr track element polyfill">Playr</a> or <a href="https://captionatorjs.com/" title="Captionator track">Captionator</a>.</li>
                    </ul>
                </section>
                <section>
                    <p>Using the track element, captions appear like this:</p>
                    <p><img alt="Screenshot showing captions displayed using the track element in Chrome on Android" src="images/Chrome-Android-track-landscape-5x3.jpg" />
                    </p>
                </section>
                <section>
                    <h2 id="add-track-element">Add track element</h2>
                    <p>It’s very easy to add captions to your video – simply add a track element as a child of the video element:</p><pre><code>    &lt;video controls&gt;
        &lt;source src="chrome.webm" type="video/webm" /&gt;
        &lt;source src="chrome.mp4" type="video/mp4" /&gt;
      &lt;track src="chrome-subtitles-en.vtt" label="English captions"
             kind="captions" srclang="en" default&gt;
      &lt;p&gt;This browser does not support the video element.&lt;/p&gt;
    &lt;/video&gt;</code></pre>
                </section>
                <section>
                    <p>The track element <code>src</code> attribute gives the location of the track file.</p>
                </section>
                <section>
                    <h2 id="define-captions-in-track-file">Define captions in track file</h2>
                    <p>A track file consists of timed ‘cues’ in WebVTT format:</p><pre><code>WEBVTT
00:00.000 --&gt; 00:04.000
Man sitting on a tree branch, using a laptop.
00:05.000 --&gt; 00:08.000
The branch breaks, and he starts to fall.
...</code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Quick Reference</h2>
                    <p>A quick overview of properties on the video element.</p>
                </section>
                <section>
                    <h2 id="video-element-attributes">Video element attributes</h2>
                    <p>For the complete list of video element attributes and their definitions, see <a href="https://www.w3.org/TR/html5/embedded-content-0.html#the-video-element">the video element spec</a>.</p>
                    <p>On desktop, <code>autoplay</code> tells the browser to immediately start downloading and playing the video as soon as it can. On iOS, and Chrome for Android, <code>autoplay</code> doesn’t work; users must tap the screen to play the video.</p>
                </section>
                <section>
                    <p>Even on platforms where autoplay is possible, you need to consider whether it’s a good idea to enable it:</p>
                    <ul>
                        <li>Data usage can be expensive.</li>
                        <li>Causing media to download and playback to begin, without asking first, can unexpectedly hog bandwidth and CPU, and thereby delay page rendering.</li>
                        <li>Users may be in a context where playing video or audio is intrusive.</li>
                    </ul>
                </section>
                <section>
                    <p>Autoplay behavior is configurable in the Android WebView via the <a href="https://developer.android.com/reference/android/webkit/WebSettings.html#setMediaPlaybackRequiresUserGesture(boolean)">WebSettings API</a>. It defaults to true but a WebView app can choose to disable it.</p>
                    <p>The <code>preload</code> attribute provides a hint to the browser as to how much information or content should be preloaded.</p>
                    <p>The <code>preload</code> attribute has different effects on different platforms. For example, Chrome buffers 25 seconds of video on desktop, none on iOS or Android. This means that on mobile, there may be playback startup delays that don’t happen on desktop. See <a href="https://stevesouders.com/tests/mediaevents.php">Steve Souders’ test page</a> for full details.</p>
                </section>
                <section>
                    <h2 id="javascript">JavaScript</h2>
                    <p><a href="https://www.html5rocks.com/en/tutorials/video/basics/#toc-javascript">The HTML5 Rocks Video article</a> does a great job of summarizing the JavaScript properties, methods, and events that can be used to control video playback. We’ve included that content here, updating it with mobile-specific concerns where relevant.</p>
                    <p>Neither playbackRate (<a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/scripted.html">see demo</a>) nor volume are supported on mobile.</p>
                    <p>On mobile (apart from Opera on Android) play() and pause() don’t work unless called in response to user action, such as clicking a button: see the <a href="http://googlesamples.github.io/web-fundamentals/samples/media/video/scripted.html">demo</a>. (Likewise, playback can’t be initiated for content such as embedded YouTube videos.)</p>
                    <p>These are only a subset of the media events that may be fired. Refer to the <a href="https://developer.mozilla.org/docs/Web/Guide/Events/Media_events">Media events</a> page on the Mozilla Developer Network for a complete listing.</p>
                </section>
            </section>